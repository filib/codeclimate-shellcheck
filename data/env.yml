---
SC1082:
  remediation_points: 50000
  content:
    body: "##  This file has a UTF-8 BOM. Remove it with: LC_CTYPE=C sed '1s/^...//'
      < yourscript .\n\n### Problematic code:\n\nThis is an encoding error that can't
      be seen in the script itself, but `cat -v` will show three bytes of garbage
      at the start of the file:\n\n```\n$ cat -v file\nM-oM-;M-?#!/bin/bash\necho
      \"hello world\"\n```\n\n### Correct code:\n\nThe code is correct when this garbage
      does not appear.\n\n### Rationale:\n\nSome editors may save a file with a [Byte
      Order Mark](https://en.wikipedia.org/wiki/Byte_order_mark) to mark the file
      as UTF-8. Shells do not understand this and will give errors on the first line:\n\n```\n$
      bash myscript\nmyscript: line 1: #!/bin/sh: No such file or directory\n\n$ dash
      myscript\nmyscript: 1: myscript: #!/bin/sh: not found\n```\n\nTo fix it, remove
      the byte order mark. One way of doing this is `LC_CTYPE=C sed '1s/^...//' <
      yourscript`. Verify that it's not there with `cat -v`. \n\n### Exceptions:\n\nNone\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2123:
  remediation_points: 50000
  content:
    body: |
      ## PATH is the shell search path. Use another name.

      ### Problematic code:

      ```sh
      PATH=/my/dir
      cat "$PATH/myfile"
      ```

      ### Correct code:

      Good practice: always use lowercase for unexported variables.

      ```sh
      path=/my/dir
      cat "$path/myfile"
      ```

      Bad practice: use another uppercase name.

      ```sh
      MYPATH=/my/dir
      cat "$MYPATH/myfile"
      ```

      ### Rationale:

      `PATH` is where the shell looks for the commands it executes. By inadvertently overwriting it, the shell will be unable to find commands (like `cat` in this case).

      You get this warning when ShellCheck suspects that you didn't meant to overwrite it (because it's a single path with no path separators).

      Best shell scripting practice is to always use lowercase variable names to avoid accidentally overwriting exported and internal variables.

      ### Exceptions

      If you're aware of the above and really do want to set your shell search path to `/my/dir`, you can ignore this warning.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2158:
  remediation_points: 50000
  content:
    body: |
      ## [ false ] is true. Remove the brackets

      ### Problematic code:

      ```sh
      if [ false ]
      then
        echo "triggers anyways"
      fi
      ```

      ### Correct code:

      ```sh
      if false
      then
        echo "never triggers"
      fi
      ```

      ### Rationale:

      `[ str ]` checks whether `str` is non-empty. It doesn't matter if `str` is `false`, it will still be evaluated for non-emptyness.

      Instead, use the command `false` which -- as the manual puts it -- does nothing, unsuccessfully.

      ### Exceptions:

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2159:
  remediation_points: 50000
  content:
    body: |
      ## [ 0 ] is true. Use 'false' instead

      ### Problematic code:

      ```sh
      if [ 0 ]
      then
        echo "always triggers"
      fi
      ```

      ### Correct code:

      ```sh
      if false
      then
        echo "never triggers"
      fi
      ```

      ### Rationale:

      `[ str ]` checks whether `str` is non-empty. It doesn't matter if `str` is `0`, it will still be evaluated for non-emptyness.

      Instead, use the command `false` which -- as the manual puts it -- does nothing, unsuccessfully.

      ### Exceptions:

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2154:
  remediation_points: 50000
  content:
    body: |
      ## var is referenced but not assigned.

      ### Problematic code:

      ```sh
      var=name
      n=42
      echo "$var_$n.jpg"   # overextended
      ```

      or

      ```sh
      target="world"
      echo "hello $tagret"  # misspelled
      ```

      or

      ```sh
      echo "Result: ${mycmd -a myfile}"  # trying to execute commands
      ```

      ### Correct code:

      ```sh
      var=name
      n=42
      echo "${var}_$n.jpg"
      ```

      or

      ```sh
      target="world"
      echo "hello $target"
      ```

      or

      ```sh
      echo "Result: $(mycmd -a myfile)"
      ```

      ### Rationale:

      ShellCheck has noticed that you reference a variable that is not assigned. Double check that the variable is indeed assigned, and that the name is not misspelled.

      Note: This message only triggers for variables with lowercase characters in their name (`foo` and `kFOO` but not `FOO`) due to the standard convention of using lowercase variable names for unexported, local variables.

      ### Exceptions:

      ShellCheck does not attempt to figure out runtime or dynamic assignments like with `source "$(date +%F).sh"` or `eval var=value`.

      If you know for a fact that the variable is set, you can use `${var:?}` to fail if the variable is unset (or empty), or explicitly initialize/declare it with `var=""` or `declare var`. You can also disable the message with a [[directive]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2120:
  remediation_points: 50000
  content:
    body: |
      # foo references arguments, but none are ever passed.

      ### Problematic code:

      ```sh
      sayhello() {
        echo "Hello $1"
      }
      sayhello
      ```

      `./myscript World` just prints "Hello " instead of "Hello World".

      ### Correct code:

      ```sh
      sayhello() {
        echo "Hello $1"
      }
      sayhello "$@"
      ```

      `./myscript World` now prints "Hello World".

      ### Rationale:

      In a function, `$1` and up refers to the function's parameters, not the script's parameters.

      If you want to process your script's parameters in a function, you have to explicitly pass them. You can do this with `myfunction "$@"`.

      Note that `"$@"` refers to the current context's positional parameters, so if you call a function from a function, you have to pass in `"$@"` to both of them:

      ```sh
      first() { second "$@"; }
      second() { echo "The first script parameter is: $1"; }
      first "$@"
      ```

      ### Exceptions

      If the parameters are optional and you currently just don't want to use them, you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2160:
  remediation_points: 50000
  content:
    body: |
      ## Instead of '[ true ]', just use 'true'.

      ### Problematic code:

      ```sh
      if [ true ]
      then
        echo "always triggers"
      fi
      ```

      ### Correct code:

      ```sh
      if true
      then
        echo "always triggers"
      fi
      ```

      ### Rationale:

      This is a stylistic suggestion to use `true` instead of `[ true ]`.

      `[ true ]` seems to suggest that the value "true" is somehow relevant to the statement. This is not the case, it doesn't matter. You can replace it with `[ false ]` or `[ wombat ]`, and it will still always be true:

      String  | In brackets  | Outside brackets
      --------|--------------|-----------------
      true    | true         | true
      false   | true         | false
      wombat  | true         | unknown command

      It's therefore better to use it without brackets, so that the "true" actually matters.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2115:
  remediation_points: 50000
  content:
    body: |
      ## Use "${var:?}" to ensure this never expands to /* .

      ### Problematic code:

      ```sh
      rm -rf "$STEAMROOT/"*
      ```

      ### Correct code:

      ```sh
      rm -rf "${STEAMROOT:?}/"*
      ```

      ### Rationale:

      If `STEAMROOT` is empty, this will [end up deleting everything](https://github.com/ValveSoftware/steam-for-linux/issues/3671) in the system's root directory.

      Using `:?` will cause the command to fail if the variable is null or unset. Similarly, you can use `:-` to set a default value if applicable.

      In the case command substitution, assign to a variable first and then use `:?`. This is relevant even if the command seems simple and obviously correct, since forks and execs can fail due to external system limits and conditions, resulting in a blank substitution.

      For more details about `:?` see the "Parameter Expansion" section of the Bash man page.
      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2201:
  remediation_points: 50000
  content:
    body: |
      ## Brace expansion doesn't happen in `[[ ]]`. Use a loop.

      ### Problematic code:

      ```sh
      [[ "$file" = index.{htm,html,php} ]] && echo "This is the main file"
      ```

      ### Correct code:

      ```sh
      for main in index.{htm,html,php}
      do
        [[ "$file" = "$main" ]] && echo "This is the main file"
      done
      ```

      ### Rationale:

      Brace expansions doesn't happen in `[[ ]]`. They will just be interpreted literally.

      Instead, use a `for` loop to iterate over values, and apply your condition to each.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2071:
  remediation_points: 50000
  content:
    body: "## > is for string comparisons. Use -gt instead.\n\n### Problematic code:\n\n```sh\nif
      [[ $var > 10 ]]\nthen\n  echo \"Incorrectly triggers when var=5\"\nfi\n```\n\n###
      Correct code:\n\n```sh\nif [[ $var -gt 10 ]]\nthen\n  echo \"Correct numerical
      comparison\"\nfi\n```\n### Rationale:\n\n`<` and `>`, in both `[[` and `[` (when
      escaped) will do a lexicographical comparison, not a numerical comparison. \n\nThis
      means that `[[ 5 > 10 ]]` is true because 5 comes after 10 alphabetically. Meanwhile
      `[[ 5 -gt 10 ]]` is false because 5 does not come after 10 numerically.\n\nIf
      you want to compare numbers by value, use the numerical comparison operators
      `-gt`, `-ge`, `-lt` and `-le`.\n\n### Exceptions:\n\nIf the strings happen to
      be version numbers and you're using <, or > to compare them as strings, and
      you consider this an acceptable thing to do, then you can ignore this warning.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1046:
  remediation_points: 50000
  content:
    body: |
      # Couldn't find 'fi' for this 'if'

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1001:
  remediation_points: 50000
  content:
    body: "## This `\\o` will be a regular 'o' in this context.\n\n### Problematic
      code:\n\n```sh\n# Want literal backslash\necho Yay \\o/\n\n# Want linefeed\ngreeting=Hello\\nWorld\n\n#
      Want other characters\ncarriagereturn=\\r\n```\n\n### Correct code:\n\n```sh\necho
      'Yay \\o/'\n\ngreeting='Hello\nWorld'\n\ncarriagereturn=$(printf '\\r')\n```\n\n###
      Rationale:\n\nYou have escaped something that has no special meaning when escaped.
      The backslash will be simply be ignored.\n\nIf the backslash was supposed to
      be literal, single quote or escape it.\n\nIf you wanted it to expand to something,
      rewrite the expression. For linefeeds (`\\n`), put them literally in quotes.
      For other characters, use POSIX `printf` or bash/ksh `$'...'`. \n\n### Exceptions\n\nNone.
      ShellCheck (as of 2017-07-03, commit 31bb02d6) will not warn when the first
      letter of a command is unnecessarily escaped, as this is frequently used to
      suppress aliases interactively. \n\n### Notice\n\nOriginal content from the
      ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1016:
  remediation_points: 50000
  content:
    body: |
      ## This is a Unicode single quote. Delete and retype it.

      ### Problematic code:

      ```sh
      echo ‘hello world’
      ```

      ### Correct code:

      ```sh
      echo 'hello world'
      ```

      ### Rationale:

      Some software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. Try deleting and retyping them, and/or disable “smart quotes” in your editor or OS.

      ### Status:

      This error was retired after 0.4.5. In this version and earlier, ShellCheck parsed slanted quotes as a valid double quote. This meant that the warning could not simply be ignored. It has since been replaced by [[SC1110]] (outside quotes) and [[SC1112]] (inside single quotes).


      ### Exceptions

      If you want to use typographic single quotes, you can put them in double quotes (or typographic double quotes in single quotes) to make shellcheck ignore them, e.g.,

      ```sh
      printf "Warning: ‘wakeonlan’ is not installed.\n"
      ```

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2146:
  remediation_points: 50000
  content:
    body: |
      ## This action ignores everything before the -o. Use \\( \\) to group.

      ### Problematic code:

      ```sh
      find . -name '*.avi' -o -name '*.mkv' -exec cp {} /media \;
      ```

      ### Correct code:

      ```sh
      find . \( -name '*.avi' -o -name '*.mkv' \) -exec cp {} /media \;
      ```

      ### Rationale:

      In `find`, two predicates with no operator between them is considered a logical, short-circuiting AND (as if using `-a`). E.g., `-name '*.mkv' -exec ..` is the same as `-name '*.mkv' -a -exec ..`.

      `-a` has higher precedence than `-o`, so `-name '*.avi' -o -name '*.mkv' -a -exec ..` is equivalent to `-name '*.avi' -o \( -name '*.mkv' -a -exec .. \)`.

      In other words, the problematic code means "if name matches `*.avi`, do nothing. Otherwise, if it matches `*.mkv`, execute a command.".

      In the correct code, we use `\( \)` to group to get the evaluation order we want. The correct code means "if name matches `*.avi` or `*.mkv`, then execute a command", which was what was intended.

      ### Exceptions

      If you're aware of this, you can either ignore this error or group to make it explicit. For example, to decompress all gz files except tar.gz, you can use:

      ```sh
      find . -name '*.tar.gz' -o \( -name '*.gz' -exec gzip -d {} + \)
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2038:
  remediation_points: 50000
  content:
    body: "## Use -print0/-0 or find -exec + to allow for non-alphanumeric filenames.\n\n###
      Problematic code:\n\n```sh\nfind . -type f | xargs md5sum\n```\n\n### Correct
      code:\n\n```sh\nfind . -type f -print0 | xargs -0 md5sum\nfind . -type f -exec
      md5sum {} +\n```\n\n### Rationale:\n\nBy default, `xargs` interprets spaces
      and quotes in an unsafe and unexpected way. Whenever it's used, it should be
      used with `-0` or `--null` to split on `\\0` bytes, and `find` should be made
      to output `\\0` separated filenames.\n\nPOSIX does not require find or xargs
      to support null terminators, so you can also use `find -exec +`. \n### Exceptions\n\nNone.\n\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2149:
  remediation_points: 50000
  content:
    body: |
      ## Remove $/${} for numeric index, or escape it for string.

      ### Problematic code:

      ```sh
      # Regular array
      index=42
      echo $((array[$index]))
      ```

      or

      ```sh
      # Associative array
      index=banana
      echo $((array[$index]))
      ```

      ### Correct code:

      ```
      # Regular array
      index=42
      echo $((array[index]))
      ```

      or

      ```sh
      # Associative array
      index=banana
      echo $((array[\$index]))
      ```

      ### Rationale:

      For a numerically indexed array, the `$` is mostly pointless and can be removed like in [[SC2004]].

      For associative arrays, the `$` should be escaped to avoid accidental dereferencing:

      ```sh
      declare -A array
      index='$1'
      array[$index]=42
      echo "$(( array[$index] ))"    # bash: array: bad array subscript
      echo "$(( array[\$index] ))"   # 42
      ```

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2191:
  remediation_points: 50000
  content:
    body: "## The = here is literal. To assign by index, use ( [index]=value ) with
      no spaces. To keep as literal, quote it.\n\n### Problematic code:\n\n```sh\narray=(
      [index] = value )\n```\n\n### Correct code:\n\n```sh\narray=( [index]=value
      )\n```\n\n### Rationale:\n\nThe shell doesn't care about the `=` sign in your
      array assignment because it's not part of a recognized index assignment. Instead,
      it's considered a literal character and becomes part of an array element's value.\n\nIn
      the example problematic code, this is because the `=` was intended to set the
      index, but the shell will not recognize it when it is surrounded by spaces.\n\nMake
      sure to remove any spaces around the `=` when assigning by index, such as in
      the correct code.\n\nIf you wanted the `=` to be a literal part of the array
      element, add quotes around it, such as `env=( \"LC_CTYPE=C\" )` or `specialChars=(
      \"=\" \"%\" \";\" )` .\n\n### Exceptions:\n\nNone. \n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2054:
  remediation_points: 50000
  content:
    body: |
      ## Use spaces, not commas, to separate array elements.

      ### Problematic code:

      ```sh
      flags=("-l", "-d", "--sort=size")
      ls "${flags[@]}"
      ```

      ### Correct code:

      ```sh
      flags=("-l" "-d" "--sort=size")
      ls "${flags[@]}"
      ```
      ### Rationale:

      You appear to have used commas to separate array elements in an array assignment. Other languages require this, but bash instead treats the commas as literal strings.

      In the problematic code, the first element is `-l,` with the trailing comma, and the executed command ends up being `ls -l, -d, --sort=size`.

      In the correct code, the trailing commas have been removed, and the command will be `ls -l -d --sort=size` as expected.

      ### Exceptions:

      None (if you actually want a trailing comma in your strings, move them inside the quotes).

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2141:
  remediation_points: 50000
  content:
    body: |
      ## Did you mean IFS=$'\t' ?

      ### Problematic code:

      ```sh
      IFS="\t"
      ```

      ### Correct code:

      ```sh
      IFS=$'\t'
      ```

      ### Rationale:

      `IFS="\t"` splits on backslash and the letter "t". `IFS=$'\t'` splits on tab.

      ### Exceptions

      It's extremely rare to want to split on the letter "n" or "t", rather than linefeed or tab.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1053:
  remediation_points: 50000
  content:
    body: |
      ## Semicolons directly after 'else' are not allowed. Just remove it.

      ### Problematic code:

      ```sh
      if mycommand; then echo "True"; else; echo "False"; fi
      ```

      ### Correct code:

      ```sh
      if mycommand; then echo "True"; else echo "False"; fi
      ```

      ### Rationale:

      `else` keywords should not be followed by semicolons. It's not valid shell syntax.

      You can follow them directly with a line break or another command.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2041:
  remediation_points: 50000
  content:
    body: |
      ## This is a literal string. To run as a command, use $(..) instead of '..' .

      ### Problematic code:

      ```sh
      for i in 'seq 1 10'
      do
        echo "$i"
      done
      ```

      ### Correct code:

      ```sh
      for i in $(seq 1 10)
      do
        echo "$i"
      done
      ```

      ### Rationale:

      The intent was to run the code in the single quotes. This would have worked with slanted backticks, `` `..` ``, but here the very similar looking single quotes `'..'` were used, resulting in a string literal instead of command output.

      This is one of the many problems with backticks, so it's better to use `$(..)` to expand commands.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2148:
  remediation_points: 50000
  content:
    body: |
      ##  Tips depend on target shell and yours is unknown. Add a shebang.

      ### Problematic code:

      ```sh
      echo "$RANDOM"   # Does this work?
      ```

      ### Correct code:

      ```sh
      #!/bin/sh
      echo "$RANDOM"  # Unsupported in sh. Produces warning.
      ```

      or

      ```sh
      #!/bin/bash
      echo "$RANDOM"  # Supported in bash. No warnings.
      ```

      ### Rationale:

      Different shells support different features. To give effective advice, ShellCheck needs to know which shell your script is going to run on. You will get a different numbers of warnings about different things depending on your target shell.

      ShellCheck normally determines your target shell from the shebang (having e.g. `#!/bin/sh` as the first line). The shell can also be specified from the CLI with `-s`, e.g. `shellcheck -s sh file`.

      If you don't specify shebang nor `-s`, ShellCheck gives this message and proceeds with some default (`bash`).

      Note that this error can not be ignored with a [[directive]]. It is not a suggestion to improve your script, but a warning that ShellCheck lacks information it needs to be helpful.

      ### Exceptions

      None. Please either add a shebang or use `-s`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1009:
  remediation_points: 50000
  content:
    body: |
      #  The mentioned parser error was in ...

      This info warning points to the start of what ShellCheck was parsing when it failed. See [[Parser error]] for example and information.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1086:
  remediation_points: 50000
  content:
    body: |
      ## Don't use $ on the iterator name in for loops.

      ### Problematic code:

      ```sh
      for $var in *
      do
        echo "$var"
      done
      ```

      ### Correct code:

      ```sh
      for var in *
      do
        echo "$var"
      done
      ```

      ### Rationale:

      The variable is named `var`, and can be expanded to its value with `$var`.

      The `for` loop expects the variable's name, not its value (and the name can not be specified indirectly).

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2086:
  remediation_points: 50000
  content:
    body: |
      # Double quote to prevent globbing and word splitting.

      ## Problematic code:

      ```sh
      echo $1
      for i in $*; do :; done # this done and the next one also applies to expanding arrays.
      for i in $@; do :; done
      ```

      ## Correct code:

      ```sh
      echo "$1"
      for i in "$@"; do :; done # or, 'for i; do'
      ```
      ## Rationale

      The first code looks like "print the first argument". It's actually "Split the first argument by IFS (spaces, tabs and line feeds). Expand each of them as if it was a glob. Join all the resulting strings and filenames with spaces. Print the result."

      The second one looks like "iterate through all arguments". It's actually "join all the arguments by the first character of IFS (space), split them by IFS and expand each of them as globs, and iterate on the resulting list". The third one skips the joining part.

      Quoting variables prevents word splitting and glob expansion, and prevents the script from breaking when input contains spaces, line feeds, glob characters and such.

      Strictly speaking, only expansions themselves need to be quoted, but for stylistic reasons, entire arguments with multiple variable and literal parts are often quoted as one:

      ```sh
      $HOME/$dir/dist/bin/$file        # Unquoted (bad)
      "$HOME"/"$dir"/dist/bin/"$file"  # Minimal quoting (good)
      "$HOME/$dir/dist/bin/$file"      # Canonical quoting (good)
      ```

      When quoting composite arguments, make sure to exclude globs and brace expansions, which lose their special meaning in double quotes: `"$HOME/$dir/src/*.c"` will not expand, but `"$HOME/$dir/src"/*.c` will.

      Note that `$( )` starts a new context, and variables in it have to be quoted independently:

      ```sh
      echo "This $variable is quoted $(but this $variable is not)"
      echo "This $variable is quoted $(and now this "$variable" is too)"
      ```

      ### Exceptions
      Sometimes you want to split on spaces, like when building a command line:

      ```sh
      options="-j 5 -B"
      make $options file
      ```

      Just quoting this doesn't work. Instead, you should have used an array (bash, ksh, zsh):

      ```bash
      options=(-j 5 -B) # ksh: set -A options -- -j 5 -B
      make "${options[@]}" file
      ```

      or a function (POSIX):

      ```sh
      make_with_flags() { make -j 5 -B "$@"; }
      make_with_flags file
      ```

      To split on spaces but not perform glob expansion, Posix has a `set -f` to disable globbing.  You can disable word splitting by setting `IFS=''`.

      Similarly, you might want an optional argument:

      ```sh
      debug=""
      [[ $1 == "--trace-commands" ]] && debug="-x"
      bash $debug script
      ```

      Quoting this doesn't work, since in the default case, `"$debug"` would expand to one empty argument while `$debug` would expand into zero arguments. In this case, you can use an array with zero or one elements as outlined above, or you can use an unquoted expansion with an alternate value:

      ```sh
      debug=""
      [[ $1 == "--trace-commands" ]] && debug="yes"
      bash ${debug:+"-x"} script
      ```

      This is better than an unquoted value because the alternative value can be properly quoted, e.g. `wget ${output:+ -o "$output"}`.

      ---

      As always, this warning can be [[ignore]]d on a case-by-case basis.

      this is especially relevant when BASH many not be available for the array work around.
      For example, use in eval or in command options where script has total control of the variables...

      ```sh
      FLAGS="-av -e 'ssh -x' --delete --delete-excluded"
      ...
      # shellcheck disable=SC2086
      eval rsync $FLAGS ~/dir remote_host:dir
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2172:
  remediation_points: 50000
  content:
    body: "## Trapping signals by number is not well defined. Prefer signal names.\n\n###
      Problematic code:\n\n```sh\ntrap myfunc 28\n```\n\n### Correct code:\n\n```sh\ntrap
      myfunc WINCH\n```\n### Rationale:\n\nSignal numbers can vary between platforms.
      Prefer signal names, which are fixed.\n\nSignal numbers 1, 2, 3, 6, 9, 14 and
      15 are specified as parts of the optional POSIX XSI and ShellCheck will not
      warn about these. \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1097:
  remediation_points: 50000
  content:
    body: |
      ## Unexpected ==. For assignment, use =. For comparison, use [/[[.

      ### Problematic code:

      ```sh
      var==value
      ```

      ### Correct code:

      Assignment:

      ```sh
      var=value
      ```

      Comparison:

      ```sh
      [ "$var" = value ]
      ```

      ### Rationale:

      ShellCheck has noticed that you're using `==` in an unexpected way. The two most common reasons for this is:

      * You wanted to assign a value but accidentally used `==` instead of `=`.

      * You wanted to compare two values, but neglected to use `[ .. ]` or `[[ .. ]]`.

      ### Exceptions:

      If you wanted to assign a literal equals sign, use quotes to make this clear:

      ```sh
      var="=sum(A1:A10)"
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1117:
  remediation_points: 50000
  content:
    body: |
      ## Backslash is literal in `"\n"`. Prefer explicit escaping: `"\\n"`.

      ### Problematic code:

      ```sh
      printf "%s\n" "Hello"
      ```

      ### Correct code:

      ```sh
      printf "%s\\n" "Hello"
      ```

      or alternatively, with single quotes:

      ```sh
      printf '%s\n' "Hello"
      ```

      ### Rationale:

      In a double quoted string, you have escaped a character that has no special behavior when escaped. Instead, it's invoking the fallback behavior of being interpreted literally.

      Instead of relying on this implicit fallback, you should escape the backslash explicitly. This makes it clear that it's meant to be passed as a literal backslash in the string parameter.

      ### Exceptions:

      None. This is a stylistic issue which can be [[ignore]]d.

      Before you do -- can you name the 4 characters that *are* special when escaped in double quotes?

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2013:
  remediation_points: 50000
  content:
    body: |
      # To read lines rather than words, pipe/redirect to a 'while read' loop.

      ### Problematic code:

      ```sh
      for line in $(cat file | grep -v '^ *#')
      do
        echo "Line: $line"
      done
      ```

      ### Correct code:

      ```sh
      grep -v '^ *#' < file | while IFS= read -r line
      do
        echo "Line: $line"
      done
      ```

      or without a subshell (bash, zsh, ksh):

      ```sh
      while IFS= read -r line
      do
        echo "Line: $line"
      done < <(grep -v '^ *#' < file)
      ```

      or without a subshell, with a pipe (more portable, but write a file on the filesystem):

      ```sh
      mkfifo mypipe
      grep -v '^ *#' < file > mypipe &
      while IFS= read -r line
      do
        echo "Line: $line"
      done < mypipe
      rm mypipe
      ```

      ### Rationale:

      For loops by default (subject to `$IFS`) read word by word. Additionally, glob expansion will occur.

      Given this text file:

      ```sh
      foo *
      bar
      ```

      The for loop will print:

      ```sh
      Line: foo
      Line: aardwark.jpg
      Line: bullfrog.jpg
      ...
      ```

      The while loop will print:

      ```sh
      Line: foo *
      Line: bar
      ```


      ### Exceptions

      If you want to read word by word, you should still use a while read loop (e.g. with `read -a` to read words into an array).

      Rare reasons for ignoring this message is if you don't care because your file only contains numbers and you're not interested in good practices, or if you've set `$IFS` appropriately and also disabled globbing.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2016:
  remediation_points: 50000
  content:
    body: |
      # Expressions don't expand in single quotes, use double quotes for that.

      ### Problematic code:

      ```sh
      name=World
      echo 'Hello $name'
      ```

      ### Correct code:

      ```sh
      name=World
      echo "Hello $name"
      ```

      ### Rationale:

      Single quotes prevent expansion of everything, including variables and command substitution.

      If you want to use the values of variables and such, use double quotes instead.

      Note that if you have other items that needs single quoting, you can use both in a single word:

      ```sh
      echo '$1 USD is '"$rate GBP"
      ```

      ### Exceptions

      If you want `$stuff` to be a literal dollar sign followed by the characters "stuff", you can [[ignore]] this message.

      ShellCheck tries to be smart about it, and won't warn when this is used with awk, perl and similar, but there are some inherent ambiguities like `'I have $1 in my wallet'`, which could be "one dollar" or "whatever's in the first parameter".

      In the particular case of `sed`, ShellCheck uses additional heuristics to try to separate cases like `'s/$foo/bar/'` (failing to replace the variable `$foo`) with from the false positives like `'$d'` (delete last line). If you're still triggering these, consider being more generous with your spaces: use `$ { s/foo/bar; }` instead of `${s/foo/bar/;}`



      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2116:
  remediation_points: 50000
  content:
    body: "## SC2116 Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.\n\n###
      Problematic code:\n\n```sh\ngreeting=$(echo \"Hello, $name\")\n# or\ntar czf
      \"$(echo \"$(date +%F).tar.gz\")\" *\n```\n\n### Correct code:\n\n```sh\ngreeting=\"Hello,
      $name\"\n# or\ntar czf \"$(date +%F).tar.gz\" *\n```\n\n### Rationale:\n\nYou
      appear to be using `echo` to write a value to stdout, and then using `$(..)`
      or `` `..` `` to capture the value again. This is as pointless as mailing yourself
      a postcard: you already have what you want, so there's no need to send it on
      a round trip.\n\nYou can just replace `$(echo myvalue)` with `myvalue`.\n\n###
      Exceptions\n\nSometimes this pattern is used because of side effect of `echo`
      or expansions. For example, here `$(echo ..)` is used to expand a glob.\n```\nglob=\"*.png\"\nfiles=\"$(echo
      $var)\"\n```\n\nThe `echo` is not useless, but this code is problematic because
      it concatenates filenames by spaces. This will break filenames containing spaces
      and other characters later when the list is split again. Better options are:\n\n*
      Arrays, if supported by the shell: `files=( $glob ); echo \"The first file is
      ${files[0]}\"`\n* Positional parameters when possible: `set -- $glob; echo \"The
      first file is $1\"`\n* Delaying expansion until it's needed: `for file in $glob;
      do ...`\n\nAll three methods will let you avoid issues with special characters
      in filenames.\n\nAs another example, here `$(echo ..)` is used to expand escape
      sequences:\n```\nunexpanded='var\\tvalue'\nexpanded=\"$(echo \"$var\")\"\n```\n\nIn
      this case, use `printf` instead. It's well defined with regard to escape sequences.
      \n\nFinally, if you really do want to concatenate a series of elements by a
      character like space, consider doing it explicitly with `for` or `printf` (e.g.
      `printf '%s\\n' $glob`).\n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC2217:
  remediation_points: 50000
  content:
    body: |
      ## Redirecting to 'echo', a command that doesn't read stdin. Bad quoting or missing xargs?

      ### Problematic code:

      ```sh
      echo << eof
        Hello World
      eof
      ```

      ### Correct code:

      ```sh
      cat << eof
        Hello World
      eof
      ```

      ### Rationale:

      You are redirecting to one of several commands that don't read from stdin.

      This may happen when:

      * Confusing one command for another, e.g. using `echo` where `cat` was intended.
      * Incorrectly quoting angle brackets, e.g. using `echo <p>Hello` which tries to read from a file `p`.
      * Missing `xargs`, e.g. `mv -t dir < files` instead of `xargs mv -t dir < files` (or more safely, `tr '\n' '\0' < files | xargs -0 mv -t dir`), because stdin should be passed as parameters.

      Check your logic, and rewrite the command so data is passed correctly.

      ### Exceptions:

      If you've overridden a command to return output, you can either rename it to make this obvious, or [[ignore]] this message.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2125:
  remediation_points: 50000
  content:
    body: |
      ## Brace expansions and globs are literal in assignments. Quote it or use an array.

      ### Problematic code:

      ```sh
      foo={1..9}
      echo $foo
      ```

      ### Correct code:

      ```sh
      foo=( {1..9} )
      echo "${foo[@]}"
      ```

      ### Rationale:

      `echo *.png {1..9}` expands to all png files and numbers from 1 to 9, but `var=*.png` or `var={1..9}` will just assign the literal strings `'*.png'` and `'{1..9}'`.

      To make the variable contain all png files or 1 through 9, use an array as demonstrated.

      If you intended to assign these values as literals, quote them (e.g. `var="*.png"`).

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2190:
  remediation_points: 50000
  content:
    body: "## Elements in associative arrays need index, e.g. array=( [index]=value
      ) .\n\n### Problematic code:\n\n```sh\ndeclare -A foo\nfoo=( myvalue )\n```\n\n###
      Correct code:\n\n```sh\ndeclare -A foo\nfoo=( [key]=myvalue )\n```\n### Rationale:\n\nYou
      appear to be initializing or appending an array element to an associative array
      without giving it an index. In an indexed array, elements will be auto-indexed
      by incremented characters. In associative arrays, the index must be given explicitly.\n\nThis
      could happen because of invalid spaces or otherwise malformed index assignment,
      such as `array=( [key] = value )`. This should instead be `array=( [key]=value
      )`.\n\n### Exceptions:\n\nShellCheck may be confused when a variable name is
      reused in different contexts. If shellcheck mistakenly believes the array is
      associated, please [[ignore]] this error. \n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2030:
  remediation_points: 50000
  content:
    body: |
      # Modification of var is local (to subshell caused by pipeline).

      See companion warning [[SC2031]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2150:
  remediation_points: 50000
  content:
    body: |
      ## -exec does not automatically invoke a shell. Use -exec sh -c .. for that.

      ### Problematic code:

      ```sh
      find . -type f -exec 'cat {} | wc -l' \;
      ```

      ### Correct code:

      ```sh
      find . -type f -exec sh -c 'cat {} | wc -l' \;         # Insecure
      find . -type f -exec sh -c 'cat "$1" | wc -l' _ {} \;  # Secure
      ```

      Sometimes the command can also be rewritten to not require `find` to invoke a shell:

      ```sh
      find . -type f -exec wc -l {} \; | cut -d ' ' -f 1
      ```

      ### Rationale:

      find `-exec` and `-execdir` uses `execve(2)` style semantics, meaning it expects an executable and zero or more arguments that should be passed to it.

      It does not use `system(3)` style semantics, meaning it does not accept a shell command as a string, to be parsed and evaluated by the system's command interpreter.

      If you want `find` to execute a shell command, you have to specify `sh` (or `bash`) as the executable, `-c` as first argument and your shell command as the second.

      To prevent command injection, the filename can be passed as a separate argument to sh and referenced as a positional parameter.

      ### Exceptions

      This warning would trigger falsely if executing a program with spaces in the path, if no other arguments were specified.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2098:
  remediation_points: 50000
  content:
    body: |
      ## This expansion will not see the mentioned assignment.

      See companion warning [[SC2097]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2124:
  remediation_points: 50000
  content:
    body: |
      ## Assigning an array to a string! Assign as array, or use * instead of @ to concatenate.

      ### Problematic code:

      ```sh
      var=$@
      for i in $var; do ..; done
      ```

      or

      ```sh
      set -- Hello World
      msg=$@
      echo "You said $msg"
      ```

      ### Correct code:

      ```sh
      var=( "$@" )
      for i in "${var[@]}"; do ..; done
      ```

      or

      ```sh
      set -- Hello World
      msg=$*
      echo "You said $msg"
      ```

      ### Rationale:

      Arrays and `$@` can contain multiple elements. Simple variables contain only one. When assigning multiple elements to one element, the default behavior depends on the shell (bash concatenates with spaces, zsh concatenates with first char of `IFS`).

      Since doing this usually indicates a bug, ShellCheck warns and asks you to be explicit about what you want.

      If you want to assign N elements as N elements, use an array, e.g. `myArray=( "$@" )`.

      If you want to assign N elements as 1 element by concatenating them, use `*` instead of `@`, e.g. `myVar=${myArray[*]}` (this separates elements with the first character of `IFS`, usually space).

      The same is true for `${@: -1}`, which results in 0 or 1 elements: `var=${*: -1}` assigns the last element or an empty string.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2017:
  remediation_points: 50000
  content:
    body: |
      ## Increase precision by replacing a/b\*c with a\*c/b.

      ### Problematic code:

      ```sh
      percent=$((count/total*100))
      ```

      ### Correct code:

      ```sh
      percent=$((count*100/total))
      ```

      ### Rationale:

      If integer division is performed before multiplication, the intermediate result will be truncated causing a loss of precision.

      In this case, if  `count=1` and `total=2`, then the problematic code results in `percent=0`, while the correct code gives `percent=50`.

      ### Exceptions:

      If you want and expect truncation you can ignore this message.

      ShellCheck doesn't warn when `b` and `c` are identical expressions, e.g. `a/10*10`, under the assumption that the intent is to rounded to the nearest 10 rather than the no-op of multiply by `1`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1048:
  remediation_points: 50000
  content:
    body: |
      ## Can't have empty then clauses (use 'true' as a no-op).

      ### Problematic code:

      ```sh
      if [ -e foo ]
      then
        # TODO: handle this
      fi
      ```
      ### Correct code:
      ```sh
      if [ -e foo ]
      then
        # TODO: handle this
        true
      fi

      # Or use the no-op colon operator ":"
      if [ -e foo ]
      then
        # TODO: handle this
        :
      fi
      ```

      ### Rationale:

      Shells do not allow empty `then` clauses. They need at least one command (and comments are not commands).

      If you want a `then` clause that does nothing, use a dummy command like `true`.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1119:
  remediation_points: 50000
  content:
    body: |
      ## Add a linefeed between end token and terminating ')'.

      ### Problematic code:

      ```sh
      var=$(fmt -s "$COLUMNS" << "eof"
      This is a bunch of text
      eof)

      ```

      ### Correct code:

      ```sh
      var=$(fmt -s "$COLUMNS" << "eof"
      This is a bunch of text
      eof
      )
      ```
      ### Rationale:

      When embedding a here document in `$(..)` or `(..)`, there needs to be a linefeed (newline) between the here doc token and the closing `)`. Please insert one.

      Failing to do so may cause warnings like this:

          bash: warning: here-document at line 15 delimited by end-of-file (wanted `eof')`
          dash: 5: Syntax error: end of file unexpected (expecting ")")

      ### Exceptions:

      This error may be incorrectly emitted for `ksh`, where this is allowed. In this case, please either write it in a standard way or ignore this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1018:
  remediation_points: 50000
  content:
    body: |
      # This is a unicode non-breaking space. Delete it and retype as space.

      You copy-pasted some code, probably from a blog or web site, which for formatting reasons contained unicode no-break spaces or unicode zero-width spaces instead of regular spaces or in words.

      To humans, a zero-width space is invisible and a non-breaking space is indistinguishable from a regular space, but the shell does not agree.

      If you have just a few, delete the indiciated space/word and retype it. If you have tons, do a search&replace in your editor (copy-paste an offending space into the search field, and type a regular space into the replace field), or use `sed -e $'s/\xC2\xA0/ /g' -e $'s/\xE2\x80\x8b//g' -i yourfile` to remove them.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2109:
  remediation_points: 50000
  content:
    body: |
      ## Instead of [ a || b ], use [ a ] || [ b ].

      ### Problematic code:

      ```sh
      [ "$1" = "-v" || "$1" = "-help" ]
      ```

      ### Correct code:

      ```sh
      [ "$1" = "-v" ] || [ "$1" = "-help" ]
      ```

      ### Rationale:

      `||` can not be used in a `[ .. ]` test expression. Instead, make two `[ .. ]` expressions and put the `||` between them.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2166:
  remediation_points: 50000
  content:
    body: |
      ## Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.

      And likewise, prefer `[ p ] || [ q ]` over `[ p -o q ]`.

      ### Problematic code:

      ```sh
      [ "$1" = "test" -a -z "$2" ]
      ```

      ### Correct code:

      ```sh
      [ "$1" = "test" ] && [ -z "$2" ]
      ```



      ### Rationale:

      `-a` and `-o` to mean AND and OR in a `[ .. ]` test expression is not well defined. They are obsolescent extensions in [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html) and the lack of additional quoting levels means that expressions involving these operators are often ambiguous. Values that begin with hyphens and the `!` string are the usual issues.

      Using multiple `[ .. ]` expressions with shell AND/OR operators `&&` and `||` is well defined and therefore preferred (but note that they have equal precedence, while `-a`/`-o` is unspecified but usually implemented as `-a` having higher precedence).

      ### Exceptions:

      If the shell variant being used is ksh derived (such as the bash shell) it will have the shell builtin command `[[ ... ]]`. This has the operators `&&`, `||`, `(`, `)`, `!` which safely avoid the ambiguity by noting which arguments were quoted and requiring the operators to be unquoted (except by the `[[ ... ]]` construct itself).


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2020:
  remediation_points: 50000
  content:
    body: |
      # tr replaces sets of chars, not words (mentioned due to duplicates).

      ### Problematic code:

      ```sh
      echo 'hello world' | tr 'hello' 'goodbye'
      ```

      ### Correct code:

      ```sh
      echo 'hello world' | sed -e 's/hello/goodbye/g'
      ```

      ### Rationale:

      `tr` is for `tr`ansliteration, turning some characters into other characters. It doesn't match strings or words, only individual characters.

      In this case, it transliterates h->g, e->o, l->d, o->y, resulting in the string "goddb wbrdd" instead of "goodbye world".

      The solution is to use a tool that does string search and replace, such as sed.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2035:
  remediation_points: 50000
  content:
    body: |
      # Use ./\*glob* or -- \*glob* so names with dashes won't become options.

      ### Problematic code:
          rm *

      ### Correct code:

          rm ./*

      or

          rm -- *

      ### Rationale

      Since files and arguments are strings passed the same way, programs can't properly determine which is which, and rely on dashes to determine what's what.

      A file named `-f` (`touch -- -f`) will not be deleted by the problematic code. It will instead be interpreted as a command line option, and `rm` will even report success.

      Using `./*` will instead cause the glob to be expanded into `./-f`, which no program will treat as an option.

      Similarly, `--` by convention indicates the end of options, and nothing after it will be treated like flags (except for some programs possibly still special casing `-` as e.g. stdin).

      Note that changing `*` to `./*` in GNU Tar parameters will add `./` prefix to path names in the created archive. This may cause subtle problems (eg. to search for a specific file in archive, the `./` prefix must be specified as well). So using `-- *` is a safer fix for GNU Tar commands.

      For more information, see "[Filenames and Pathnames in Shell: How to do it Correctly](http://www.dwheeler.com/essays/filenames-in-shell.html)".


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2068:
  remediation_points: 50000
  content:
    body: |
      ## Double quote array expansions to avoid re-splitting elements.

      ### Problematic code:

      ```sh
      cp $@ ~/dir
      ```

      ### Correct code:

      ```sh
      cp "$@" ~/dir
      ```

      ### Rationale:

      Double quotes around `$@` (and similarly, `${array[@]}`) prevents globbing and word splitting of individual elements, while still expanding to multiple separate arguments.

      Let's say you have three arguments: `baz`, `foo bar` and `*`

      `"$@"` will expand into exactly that: `baz`, `foo bar` and `*`

      `$@` will expand into multiple other arguments: `baz`, `foo`, `bar`, `file.txt` and `otherfile.jpg`

      Since the latter is rarely expected or desired, ShellCheck warns about it.

      ### Exceptions

      When you want globbing of individual elements.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2147:
  remediation_points: 50000
  content:
    body: |
      ##  Literal tilde in PATH works poorly across programs.

      ### Problematic code:

      ```sh
      PATH="$PATH:~/bin"
      ```

      ### Correct code:

      ```sh
      PATH="$PATH:$HOME/bin"
      ```

      ### Rationale:

      Having literal `~` in PATH is a bad idea. Bash handles it, but nothing else does.

      This means that even if you're always using Bash, you should avoid it because any invoked program that relies on PATH will effectively ignore those entries.

      For example, `make` may say `foo: Command not found` even though `foo` works fine from the shell and Make and Bash both use the same PATH. You'll get similar messages from any non-bash scripts invoked, and `whereis` will come up empty.

      Use `$HOME` or full path instead.

      ### Exceptions

      If your directory name actually contains a literal tilde, you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2059:
  remediation_points: 50000
  content:
    body: |
      # Don't use variables in the printf format string. Use printf "..%s.." "$foo".

      ### Problematic code:

      ```sh
      printf "Hello, $NAME\n"
      ```

      ### Correct code:

      ```sh
      printf "Hello, %s\n" "$NAME"
      ```

      ### Rationale:

      `printf` interprets escape sequences and format specifiers in the format string. If variables are included, any escape sequences or format specifiers in the data will be interpreted too, when you most likely wanted to treat it as data. Example:

      ```sh
      coverage='96%'
      printf "Unit test coverage: %s\n" "$coverage"
      printf "Unit test coverage: $coverage\n"
      ```

      The first printf writes `Unit test coverage: 96%`.

      The second writes ``bash: printf: `\': invalid format character``

      ### Exceptions

      Sometimes you may actually want to interpret data as a format string, like in:

      ```sh
      hexToAscii() { printf "\x$1"; }
      hexToAscii 21
      ```

      or when you have a pattern in a variable:

      ```sh
      filepattern="file-%d.jpg"
      printf -v filename "$filepattern" "$number"
      ```

      These are valid use cases with no useful rewrites. Please [[ignore]] the warnings with a [[directive]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2212:
  remediation_points: 50000
  content:
    body: |
      ## Use 'false' instead of empty [/[[ conditionals.

      ### Problematic code:

      ```sh
      if [ ]
      then
        echo "Temporarily disabled"
      fi
      ```

      ### Correct code:

      ```sh
      if false
      then
        echo "Temporarily disabled"
      fi
      ```
      ### Rationale:

      `[ ]` is a somewhat obscure way of expressing falsehood, and the behavior is likely intended to allow the incorrectly quoted command `[ $var ]` to still work when the variable is unset.

      POSIX has a more descriptive command `false` for this.

      ### Exceptions:

      None. This is a stylistic suggestion, and has no effect on how the script works.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2215:
  remediation_points: 50000
  content:
    body: "## This flag is used as a command name. Bad line break or missing `[ ..
      ]`?\n\n### Problematic code:\n\n```sh\nif -e .bashrc\nthen\n  echo \".bashrc
      already exists\"\nfi\n```\n\nor\n\n```sh\nfind . -name '*.mkv'\n       -exec
      mplayer {} \\;\n```\n\n### Correct code:\n\n```sh\nif [ -e .bashrc ]\nthen\n
      \ echo \".bashrc already exists\"\nfi\n```\n\nor\n\n```sh\nfind . -name '*.mkv'
      \\\n       -exec mplayer {} \\;\n```\n### Rationale:\n\nYou are using a name
      that starts with a dash as a command name. This is almost always a bug.\n\nThere
      are two typical ways in which this happens:\n\n* Missing `[ .. ]` or `[[ ..
      ]]` around a test expression, like in the first example example. \n* An invalid
      line break that splits a command in two, like in the second example.\n\n###
      Exceptions:\n\nIf you actually have a command that starts with a dash -- which
      you really reconsider -- you can quote the name (or at least the leading dash).
      This makes no difference to the shell, but makes it clear to ShellCheck and
      humans that this is not intended as a flag.\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2114:
  remediation_points: 50000
  content:
    body: "## Warning: deletes a system directory. \n\n### Problematic code:\n\n```sh\nrm
      -rf /usr /lib/nvidia-current/xorg/xorg\n```\n\n### Correct code:\n\n```sh\nrm
      -rf /usr/lib/nvidia-current/xorg/xorg\n```\n\n### Rationale:\n\nThe example
      line of code was an actual bug in the [Bumblebee NVIDIA driver](https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/commit/a047be85247755cdbe0acce6f1dafc8beb84f2ac).\n\nDue
      to an accidental space, it deleted `/usr` instead of just the particular directory.\n\n###
      Exceptions:\n\nIf you do intend to delete a system directory, such as when working
      in a chroot or initramfs, you can disable this message with a directive: \n\n```sh\n#
      shellcheck disable=SC2114\nrm -rf /usr \n```\n\nPrevious versions of shellcheck,
      up to and including 0.4.6, would ignore `rm` statements containing a `--` (an
      arbitrary convention). This is no longer the case.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2188:
  remediation_points: 50000
  content:
    body: "## This redirection doesn't have a command. Move to its command (or use
      'true' as no-op).\n\n### Problematic code:\n\n```sh\n{ \n  echo \"Report for
      $(date +%F)\"\n  uptime\n  df -h\n}\n  > report.txt\n```\n\n### Correct code:\n\n```sh\n{
      \n  echo \"Report for $(date +%F)\"\n  uptime\n  df -h\n} > report.txt\n```\n###
      Rationale:\n\nShellCheck found a redirection that doesn't actually redirect
      from/to anything.\n\nThis could indicate a bug, such as in the problematic code
      where an additional linefeed causes `report.txt` to be truncated instead of
      containing report output, or in `foo & > bar`, where either `foo &> bar` or
      `foo > bar &` was intended. \n\nHowever, it could also be intentionally used
      to truncate a file or check that it's readable. You can make this more explicit
      for both ShellCheck and human readers by using `true` or `:` as a dummy command,
      e.g. `true > file` or `: > file`. \n \n### Exceptions:\n\nThere are no semantic
      problems with using `> foo` over `true > foo`, so if you don't see this as a
      potential source of bugs or confusion, you can [[ignore]] it.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2192:
  remediation_points: 50000
  content:
    body: "## This array element has no value. Remove spaces after = or use \"\" for
      empty string.\n### Problematic code:\n\n```sh\narray=([1]=one [2]= two)\n```\n\n###
      Correct code:\n\n```sh\narray=([1]=one [2]=two)\n```\n### Rationale:\n\nYou
      have an array element on the form `[index]=`. The shell will interpret this
      as an independent element with index `index` and value `<empty string>`.\n\nThis
      may happen as part of the expression `[index]= value`, where the space is not
      allowed and causes the shell to interpret it as `[index]=\"\" [index+1]=value`.\n\nIf
      you wanted the element to have a value, remove the spaces after `=`, e.g. `[index]=value`.\n\nIf
      you wanted to assign an empty string, explicitly use emtpy quotes: `[index]=\"\"`.
      This makes no difference to the shell, but will make your intention clear to
      shellcheck and other humans. \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2117:
  remediation_points: 50000
  content:
    body: |
      ## To run commands as another user, use su -c or sudo.

      ### Problematic code:

      ```sh
      whoami
      su
      whoami
      ```

      ### Correct code:

      ```sh
      whoami
      sudo whoami
      ```

      ### Rationale:

      It's commonly believed that `su` makes a session run as another user. In reality, it starts an entirely new shell, independent of the one currently running your script.

      `su; whoami` will start a root shell and wait for it to exit before running `whoami`. It will not start a root shell and then proceed to run `whoami` in it.

      To run commands as another user, use `sudo some command` or `su -c 'some command'`. `sudo` is preferred when available, as it doesn't require additional quoting and can be configured to run passwordless if desired.


      ### Exceptions

      If you're aware of the above and want to e.g. start an interactive shell for a user, feel free to ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2066:
  remediation_points: 50000
  content:
    body: |
      ## Since you double quoted this, it will not word split, and the loop will only run once.

      ### Problematic code:

      ```sh
      for s in "$(mycommand)"; do echo "$s"; done
      ```

      ### Correct code:

      The correct code depends on your intention. Let's say you're in a directory with the files `file.png` and `My cat.png`, and you want to loop over a command that outputs (or variable that contains):

      ```sh
      hello world
      My *.png
      ```

      #### Loop over each line without globbing (`hello world`, `My *.png`)

      ```sh
      mycommand | while IFS= read -r s; do echo "$s"; done
      ```

      #### Loop over each word with globbing (`hello`, `world`, `My`, `file.png`, `My cat.png`):

      ```sh
      # relies on the fact that IFS by default contains space-tab-linefeed
      for s in $(mycommand); do echo "$s"; done
      ```

      #### Loop over each line with globbing (`hello world`, `My cat.png`)

      ```sh
      # explicitly set IFS to contain only a line feed
      IFS='
      '
      for s in $(mycommand); do echo "$s"; done
      ```

      ### Rationale:

      You get this warning because you have a loop that will only ever run exactly one iteration. Since you have a loop, you clearly expect it to run more than once. You just have to decide how it should be split up.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1045:
  remediation_points: 50000
  content:
    body: |
      # It's not 'foo &; bar', just 'foo & bar'.

      ### Problematic code:

      ```sh
      foo &; bar
      ```

      ### Correct code:

      ```sh
      foo & bar
      ```

      ### Rationale:

      Both `&` and `;` terminate the command. You should only use one of them.



      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2207:
  remediation_points: 50000
  content:
    body: |
      ## Prefer mapfile or read -a to split command output (or quote to avoid splitting).

      ### Problematic code:

      ```sh
      array=( $(mycommand) )
      ```

      ### Correct code:

      If the output should be a single element:

      ```sh
      array=( "$(mycommand)" )
      ```

      If it outputs multiple lines, each of which should be an element:

      ```sh
      # For bash
      mapfile -t array < <(mycommand)

      # For ksh
      mycommand | while IFS="" read -r line; do array+=("$line"); done
      ```

      If it outputs a line with multiple words (separated by spaces, other delimiters can be chosen with IFS), each of which should be an element:

      ```sh
      # For bash
      IFS=" " read -r -a array <<< "$(mycommand)"

      # For ksh
      IFS=" " read -r -A array <<< "$(mycommand)"
      ```

      ### Rationale:

      You are doing unquoted command expansion in an array. This will invoke the shell's sloppy word splitting and glob expansion.

      Instead, prefer explicitly splitting (or not splitting):

      * If the command output should become a single array element, quote it.
      * If you want to split the output into lines or words, use `mapfile`, `read -ra` and/or `while` loops as appropriate.

      This prevents the shell from doing unwanted splitting and glob expansion, and therefore avoiding problems with output containing spaces or special characters.

      ### Exceptions:

      If you have already taken care (through setting IFS and `set -f`) to have word splitting work the way you intend, you can ignore this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2139:
  remediation_points: 50000
  content:
    body: "## This expands when defined, not when used. Consider escaping.\n\n###
      Problematic code:\n\n```sh\nalias whereami=\"echo $PWD\"\n```\n\n### Correct
      code:\n\n```sh\nalias whereami='echo $PWD'\n```\n\n### Rationale:\n\nWith double
      quotes, this particular alias will be defined as `echo /home/me`, so it will
      always print the same path. This is rarely intended.\n\nBy using single quotes
      or escaping any expansions, we define the alias as `echo $PWD`, which will be
      expanded when we use the alias. This is the far more common use case.\n\nNote
      that even if you expect that the variable will never change, it may still be
      better to quote it. This prevents a second round of evaluation later:\n\n    default=\"Can't
      handle failure, aborting\"\n    trap \"echo $default; exit 1\" err\n    false
      \n\nThe trap now has a syntax error, because instead of running `echo $default`,
      it runs `echo Can't handle ..` which has an unmatched single quote. Avoid early
      expansion unless you're equally comfortable putting `eval` in there.\n\n###
      Exceptions\n\nIf you don't mind that your alias definition is expanded at define
      time (and its result expanded again at evaluation time), you can ignore this
      warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2129:
  remediation_points: 50000
  content:
    body: |
      ## Consider using { cmd1; cmd2; } >> file instead of individual redirects.

      ### Problematic code:

      ```sh
      echo foo >> file
      date >> file
      cat stuff  >> file

      ```

      ### Correct code:

      ```sh
      {
        echo foo
        date
        cat stuff
      } >> file
      ```

      ### Rationale:

      Rather than adding `>> something` after every single line, you can simply group the relevant commands and redirect the group.

      ### Exceptions

      This is mainly a stylistic issue, and can freely be ignored.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2163:
  remediation_points: 50000
  content:
    body: |
      ## Exporting an expansion rather than a variable.

      ### Problematic code:

      ```sh
      MYVAR=foo
      export $MYVAR
      ```

      ### Correct code:

      ```sh
      MYVAR=foo
      export MYVAR
      ```

      ### Rationale:

      `export` takes a variable name, but shellcheck has noticed that you give it an expanded variable instead. The problematic code does not export `MYVAR` but a variable called `foo` if any.

      ### Exceptions:

      If you do want to export the variable's value, e.g. due to indirection, you can disable this message with a directive:

      ```sh
      # shellcheck disable=SC2163
      export "$MYVAR"
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2029:
  remediation_points: 50000
  content:
    body: |
      ## Note that, unescaped, this expands on the client side.

      ### Problematic code:

      ```sh
      ssh host "echo $HOSTNAME"
      ```

      ### Correct code:

      ```sh
      ssh host "echo \$HOSTNAME"
      ```

      or

      ```sh
      ssh host 'echo $HOSTNAME'
      ```

      ### Rationale:

      Bash expands all arguments that are not escaped/singlequoted. This means that the problematic code is identical to

      ```sh
      ssh host "echo clienthostname"
      ```

      and will print out the client's hostname, not the server's hostname.

      By escaping the `$` in `$HOSTNAME`, it will be transmitted literally and evaluated on the server instead.

      ### Exceptions

      If you do want your string expanded on the client side, you can safely ignore this message.

      Keep in mind that the expanded string will be evaluated again on the server side, so for arbitrary variables and command output, you may need to add a layer of escaping with e.g. `printf %q`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2070:
  remediation_points: 50000
  content:
    body: |
      ## -n doesn't work with unquoted arguments. Quote or use [\[ ]].

      ### Problematic code:

      ```sh
      if [ -n $var ]
      then
        echo "var has a value"
      else
        echo "var is empty"
      fi
      ```

      ### Correct code:

      In POSIX:

      ```sh
      if [ -n "$var" ]
      then
        echo "var has a value"
      else
        echo "var is empty"
      fi
      ```

      In bash/ksh:

      ```sh
      if [[ -n $var ]]
      then
        echo "var has a value"
      else
        echo "var is empty"
      fi
      ```


      ### Rationale:

      When `$var` is unquoted, a blank value will cause it to wordsplit and disappear. If `$var` is empty, these two statements are identical:

      ```sh
      [ -n $var ]
      [ -n ]
      ```

      `[ string ]` is shorthand for testing if a string is empty. This is still true if `string` happens to be `-n`. `[ -n ]` is therefore true, and by extension so is `[ -n $var ]`.

      To fix this, either quote the variable, or (if your shell supports it) use `[[ -n $var ]]` which generally has fewer caveats than `[`.

      ### Exceptions:

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2155:
  remediation_points: 50000
  content:
    body: |
      ## Declare and assign separately to avoid masking return values.

      ### Problematic code:

      ```sh
      export foo="$(mycmd)"
      ```

      ### Correct code:

      ```sh
      foo=$(mycmd)
      export foo
      ```

      ### Rationale:

      In the original code, the return value of `mycmd` is ignored, and `export` will instead always return true. This may prevent conditionals, `set -e` and traps from working correctly.

      When first marked for export and assigned separately, the return value of the assignment will be that of `mycmd`. This avoids the problem.

      ### Exceptions:

      If you intend to ignore the return value of an assignment, you can either ignore this warning or use

      ```sh
      foo=$(mycmd) || true
      export foo
      ```

      Shellcheck does not warn about `export foo=bar` because `bar` is a literal and not a command substitution with an independent return value. It also does not warn about `local -r foo=$(cmd)`, where declaration and assignment must be in the same command.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1094:
  remediation_points: 50000
  content:
    body: |
      ## Parsing of sourced file failed. Ignoring it.

      ### Problematic code:

      ```sh
      source mylib
      ```

      ### Correct code:

      ```sh
      # shellcheck disable=SC1094
      source mylib
      ```

      (or fix `mylib`)

      ### Rationale:

      ShellCheck encountered a parsing error in a sourced file, `mylib` in the example.

      Fix parsing error, or just disable it with a directive.

      ### Exceptions:

      If the file is fine and this is due to a known `shellcheck` bug, you can ignore it with a [[directive]] as in the example.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1102:
  remediation_points: 50000
  content:
    body: "## Shells disambiguate $(( differently or not at all. If the first $( should
      start command substitution, add a space after it.\n\n### Problematic code:\n\n```sh\necho
      \"$((cmd \"$@\") 2>&1)\"\n```\n\n### Correct code:\n\n```sh\necho \"$( (cmd
      \"$@\") 2>&1)\"\n```\n### Rationale:\n\nYou appear to be using `$((` with two
      (or more) parentheses in a row, where the first `$(` should open a subshell.
      \n\nThis is an ill-defined structure that is parsed differently between different
      shells and shell versions. Prefer adding spaces to make it unambiguous, both
      to shells and humans.\n\nConsider the `$(((` in `$(((1)) )`:\n\nAsh, dash and
      Bash 1 parses it as `$(( (` and subsequently fail to find the matching `))`.
      Zsh and Bash 2+ looks ahead and parses it as `$( ((`. Ksh parses it as `$( (
      (`. \n\n### Exceptions:\n\n**Alternatively**, you may indeed have correctly
      spaced your parentheses, but ShellCheck failed to parse `$((` as an arithmetic
      expression while accidentally succeeding in parsing it as `$(` + `(`. \n\nIn
      these cases, double check the syntax to ensure ShellCheck can parse the `$((`,
      or ignore this error and hope that it won't affect analysis too severely. \n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1113:
  remediation_points: 50000
  content:
    body: |
      ## Use #!, not just #, for the shebang.

      ### Problematic code:

      ```sh
      # /bin/bash
      echo "Hello World"
      ```

      ### Correct code:

      ```sh
      #! /bin/bash
      echo "Hello World"
      ```
      ### Rationale:

      You appear to be specifying a shebang, but missing the bang (i.e. `!`). The shebang should always be on the form `#!/path/shell`.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1078:
  remediation_points: 50000
  content:
    body: |
      # Did you forget to close this double quoted string?

      ### Problematic code:

      ```sh
      greeting="hello
      target="world"
      ```

      ### Correct code:

      ```sh
      greeting="hello"
      target="world"
      ```

      ### Rationale:

      The first line is missing a quote.

      ShellCheck warns when it detects multi-line double quoted, single quoted or backticked strings when the character that follows it looks out of place (and gives a companion warning [[SC1079]] at that spot).

      ### Exceptions

      If you do want a multiline variable, just make sure the character after it is a quote, space or line feed.

      ```sh
      var='multiline
      'value
      ```

      can be rewritten for readability and to remove the warning:

      ```sh
      var='multiline
      value'
      ```

      As always `` `..` `` should be rewritten to ``$(..)``.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2186:
  remediation_points: 50000
  content:
    body: |
      ## tempfile is deprecated. Use mktemp instead.

      ### Problematic code:

      ```sh
      tmp=$(tempfile)
      ```

      ### Correct code:

      ```sh
      tmp=$(mktemp)
      ```
      ### Rationale:

      `tempfile` is a Debian specific utility for creating temporary files. Its man page notes:

      >tempfile is deprecated; you should use mktemp(1) instead.

      Neither `tempfile` nor `mktemp` are POSIX, but `tempfile` is Debian specific while `mktemp` works on GNU, OSX, BusyBox, *BSD and Solaris.

      ### Exceptions:

      ShellCheck will not recognize when a function overrides this name.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2185:
  remediation_points: 50000
  content:
    body: |
      ## Some finds don't have a default path. Specify '.' explicitly.

      ### Problematic code:

      ```sh
      find -type f
      ```

      ### Correct code:

      ```sh
      find . -type f
      ```
      ### Rationale:

      When not provided a search path, GNU and Busybox `find` will use a default path of `.`, the current directory.

      On POSIX, macOS/OSX, FreeBSD, OpenBSD and NetBSD, it will instead result in an error.

      Explicitly specifying a path works across all implementations, and is therefore preferred.

      ### Exceptions:

      You will get a false positive if you concatenate a series of pre-path flags:

          find -XLE .

      In such cases, please either use `find -X -L -E .` or [[ignore]] the message.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2130:
  remediation_points: 50000
  content:
    body: |
      ## -eq is for integer comparisons. Use = instead.

      ### Problematic code:

      ```sh
      [[ $foo -eq "Y" ]]
      ```

      ### Correct code:

      ```sh
      [[ $foo = "Y" ]]
      ```

      ### Rationale:

      Shells have two sets of comparison operators: for integers (`-eq`, `-gt`, ...) and strings (`=`, `>`, ...). ShellCheck has noticed that you're using an integer comparison with string data.

      If you are in fact comparing integers, double check your parameters. Certain mistakes like `$$foo` or `${bar}}` can introduce non-numeric characters into otherwise numeric arguments.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2169:
  remediation_points: 50000
  content:
    body: "## In dash, [\\[ ]] is not supported.\n\nYou are writing a script for `dash`,
      but you're using a feature that `dash` doesn't support (in this case, bash/ksh
      style `[[ .. ]]` conditions). \n\nSee Ubuntu's [DashAsBinSh](https://wiki.ubuntu.com/DashAsBinSh)
      migration guide for how to make bash-specific scripts dash-compatible.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2096:
  remediation_points: 50000
  content:
    body: |
      ## On most OS, shebangs can only specify a single parameter.

      ### Problematic code:

      ```sh
      #!/usr/bin/env bash -x
      ```

      ### Correct code:

      ```sh
      #!/usr/bin/env bash
      set -x
      ```

      ### Rationale:

      Most operating systems, including POSIX, Linux and FreeBSD, allow only a single parameter in the shebang. The example is equivalent to calling `env 'bash -x'` instead of `env 'bash' '-x'`, and it will therefore fail.

      The shebang should be rewritten to use at most one parameter. Shell options can instead be set in the body of the script.

      ### Exceptions

      macOS X currently allows multiple words in the shebang. Scripts running on OSX exclusively can ignore this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1065:
  remediation_points: 50000
  content:
    body: |
      ## Trying to declare parameters? Don't. Use () and refer to params as $1, $2..

      ### Problematic code:

      ```sh
      foo(input) {
        echo "$input"
      }
      foo("hello world");
      ```

      ### Correct code:

      ```sh
      foo() {
        echo "$1"
      }
      foo "hello world"
      ```

      ### Rationale:

      Shell script functions behave just like scripts and other commands:

        - They always take a 0 to N parameters, referred to with `$1`, `$2` etc. They can not declare parameters by name.
        - They are executed using `name arg1 arg2`, and not with parentheses as C-like languages.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1073:
  remediation_points: 50000
  content:
    body: |
      # Couldn't parse this ...

      This parsing error points to the structure ShellCheck was trying to parse when a parser error occurred. See [[Parser error]] for more information.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2193:
  remediation_points: 50000
  content:
    body: "## The arguments to this comparison can never be equal. Make sure your
      syntax is correct.\n\n### Problematic code:\n\n```sh\n[[ \"{$var}\" == \"value\"
      ]]      # Swapped around $ and {\n[[ \"$(cmd1) | cmd2\" == \"42\" ]] # Ended
      with ) too soon\n[[ \"$var \" == *.png ]]         # Trailing space\n```\n\n###
      Correct code:\n\n```sh\n[[ \"${var}\" == \"value\" ]]      # Correct variable
      expansion\n[[ \"$(cmd1 | cmd2)\" == \"42\" ]] # Correct command substitution\n[[
      \"$var\" == *.png ]]          # No trailing space\n```\n### Rationale:\n\nShellCheck
      has determined that the two values you're comparing can never be equal. \n\nMost
      of the time, this happens because of a syntax issue that introduced unintended
      literal characters into one of the arguments.\n\nThe left-hand side in the problematic
      examples will always contain (respectively) curly braces, pipe and trailing
      space. The right-hand sides are literal values and a pattern without trailing
      spaces, so they will never be equal. The statement is therefore useless, strongly
      indicating a bug. \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2097:
  remediation_points: 50000
  content:
    body: |
      ## This assignment is only seen by the forked process.

      ### Problematic code:

      ```sh
      name=World cmd -m "Hello $name"
      ```

      ### Correct code:

      ```sh
      export name=World
      cmd -m "Hello $name"
      ```

      To prevent setting the variable, this can also be done in a subshell:

      ```sh
      (
         export name=World
         cmd -m "Hello $name"
      ) # 'name' does not leave this subshell
      ```

      ### Rationale:

      In `name=World cmd "$name"`, `name=World` is passed in as part of the environment to `cmd` (i.e., in the `envp` parameter to [execve(2)](http://linux.die.net/man/2/execve)).  This means that `cmd` and its children will see the parameter, but no other processes will.

      However, `"$name"` is not expanded by `cmd`. `"$name"` is expanded by the shell before `cmd` is ever executed, and thus it will not use the new value.

      The solution is to set the variable and export the variable first. If limited scope is desired, a `( subshell )` can be used.

      ### Exceptions

      In the strange and fabricated scenarios where the script and a program uses a variable name for two different purposes, you can ignore this message. This is hard to conceive, since scripts should use lowercase variable names specifically to avoid collisions with the environment.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2092:
  remediation_points: 50000
  content:
    body: |
      ## Remove backticks to avoid executing output.

      Backticks does the same thing as `$(..)`. See [[SC2091]] for a description of the same problem with this syntax.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2121:
  remediation_points: 50000
  content:
    body: |
      # To assign a variable, use just 'var=value', no 'set ..'.

      ### Problematic code:

      ```sh
      set var=42
      set var 42
      ```

      ### Correct code:

      ```sh
      var=42
      ```

      ### Rationale:

      `set` is not used to set or assign variables in Bourne shells. It's used to set shell options and positional parameters.

      To assign variables, use `var=value` with no `set` or other qualifiers.

      ### Exceptions

      If you actually do want to set positional parameters, simply quoting them or using `--` will make shellcheck stop warning, e.g. `set -- var1 var2` or `set "foo=bar"`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1010:
  remediation_points: 50000
  content:
    body: "## Use semicolon or linefeed before 'done' (or quote to make it literal).\r\n\r\n###
      Problematic code:\r\n\r\n```\r\nfor f in *; do echo \"$f\" done\r\n```\r\nor\r\n\r\n```\r\necho
      $f is done\r\n```\r\n\r\n### Correct code:\r\n\r\n```\r\nfor f in *; do echo
      \"$f\"; done\r\n```\r\n\r\nor\r\n\r\n```\r\necho \"$f is done\"\r\n```\r\n\r\n\r\n###
      Rationale:\r\n\r\n`done` only works as a keyword when it's the first token of
      the command. If added after a command, it will just be the literal word \"done\".
      \r\n\r\nThis is also true for other keywords like `then`.\r\n\r\n### Exceptions\r\n\r\nIf
      you're intentionally using `done` as a literal, you can quote it to make this
      clear to shellcheck (and also human readers), e.g. instead of `echo Task is
      done`, use `echo \"Task is done\"`. This makes no difference to the shell, but
      it will silence this warning.\r\n\n\n### Notice\n\nOriginal content from the
      ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1042:
  remediation_points: 50000
  content:
    body: |2
          Found 'eof' further down, but not on a separate line.
          Close matches include '-eof' (!= 'eof').

      See companion error [[SC1041]].

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1105:
  remediation_points: 50000
  content:
    body: |
      ## Shells disambiguate (( differently or not at all. If the first ( should start a subshell, add a space after it.

      See [[SC1102]], the similar warning for ambiguous `$((`.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2220:
  remediation_points: 50000
  content:
    body: |
      ## Invalid flags are not handled. Add a `*)` case.

      ### Problematic code:

      ```sh
      #!/bin/sh
      while getopts "vr" f
      do
        case "$f" in
          v) echo "verbose" ;;
          r) echo "recursive" ;;
        esac
      done
      ```

      ### Correct code:

      ```sh
      #!/bin/sh
      while getopts "vr" f
      do
        case "$f" in
          v) echo "verbose" ;;
          r) echo "recursive" ;;
          *) echo "usage: $0 [-v] [-r]" >&2
             exit 1 ;;
        esac
      done
      ```

      ### Rationale:

      The `case` statement handling `getopts` arguments does not have a default branch to handle unknown flags.

      When a flag is not recognized, such as if passing `-Z` to the example code, `getopts` will set the variable to a literal question mark `?`. This should be handled along with all the valid flags, usually by printing a usage message and exiting with failure.

      Using a `\?)` or `?)` case will also match invalid flags, but`*)` would additionally match things like the empty string if the variable name was misspelled.

      ### Exceptions:

      If your script's logic handles unrecognized flags in another way, e.g. after the `case` statement, you can ignore this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2197:
  remediation_points: 50000
  content:
    body: "##  fgrep is non-standard and deprecated. Use grep -F instead.\n\n### Problematic
      code:\n\n```sh\nfgrep '*.*' file\n```\n\n### Correct code:\n\n```sh\ngrep -F
      '*.*' file\n```\n### Rationale:\n\n`fgrep` is a non-standard command. Its functionality
      is provided in POSIX by `grep -F`. [POSIX grep](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/grep.html)
      says:\n\n>This grep has been enhanced in an upwards-compatible way to provide
      the exact functionality of the historical egrep and fgrep commands as well.
      It was the clear intention of the standard developers to consolidate the three
      greps into a single command.\n\nman grep for GNU says:\n\n>Direct invocation
      as either egrep or fgrep is deprecated\n\n### Exceptions:\n\nShellCheck will
      fail to recognize when functions override `fgrep`. Consider giving it a different
      name or [[ignore]] this error. \n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC1091:
  remediation_points: 50000
  content:
    body: |
      ## Not following: (error message here)

      Reasons include: file not found, no permissions, not included on the command line, not allowing `shellcheck` to follow files with `-x`, etc.

      ### Problematic code:

      ```sh
      source somefile
      ```

      ### Correct code:

      ```sh
      # shellcheck disable=SC1091
      source somefile
      ```

      ### Rationale:

      ShellCheck, for whichever reason, is not able to access the source file.

      This could be because you did not include it on the command line, did not use `shellcheck -x` to allow following other files, don't have permissions or a variety of other problems.

      Feel free to ignore the error with a [[directive]].

      ### Exceptions:

      If you're fine with it, ignore the message with a [[directive]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1087:
  remediation_points: 50000
  content:
    body: |
      ## Braces are required when expanding arrays, as in ${array[idx]}.

      ### Problematic code:

      ```sh
      echo "$array[@]"
      ```

      ### Correct code:

      ```sh
      echo "${array[@]}"
      ```

      ### Rationale:

      For compatibility reasons, `$foo[bar]` is interpreted as the variable `$foo` followed by the literal string `[bar]`.

      Curly braces are needed to tell the shell that the square brackets are part of the expansion.

      ### Exceptions

      If you want the square brackets to be treated literally or as a glob, you can use `${var}[idx]` to prevent this warning.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2021:
  remediation_points: 50000
  content:
    body: |
      ## Don't use [] around ranges in tr, it replaces literal square brackets.

      ### Problematic code:

      ```sh
      tr -cd '[a-z]'
      ```

      ### Correct code:

      ```sh
      tr -cd 'a-z'
      ```
      ### Rationale:

      Ancient System V `tr` required brackets around operands, but modern implementations including POSIX, GNU, OS X and *BSD instead treat them as literals.

      Unless you want to operate on literal square brackets, don't include them.

      ### Exceptions:

      If you do want to replace literal square brackets, reorder the expression (e.g. `a-z[]` to make it clear that the brackets are not special).

      ShellCheck does not warn about correct usage of `[..]` in character and equivalence classes like `[:lower:]` and `[=e=]`.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1041:
  remediation_points: 50000
  content:
    body: |
      ## Found 'eof' further down, but not on a separate line.

          Close matches include '-eof' (!= 'eof').

      ### Problematic code:

      ```sh
      cat <<-eof
      Hello World
      -eof
      ```

      ### Correct code:

      ```sh
      cat <<- eof
      Hello World
      eof
      ```
      ### Rationale:

      Your here document isn't properly terminated.

      There is a line containing the terminator you've chosen, but it's not by itself on a separate line.

      In the example code, the script uses `<<-eof`, which is the operator `<<-` followed by `eof`. The script therefore looks for `eof` and skips right past the intended terminator because it starts with a dash.

      You will get some companion SC1042 errors mentioning lines that contain the string as a substring, though they all point to the start of the here document and not the relevant line:

      ```
      In foo line 4:
      Hello
      ^-- SC1041: Found 'eof' further down, but not on a separate line.
      ^-- SC1042: Close matches include '-eof' (!= 'eof').
      ```

      Look at your here document and see which line was supposed to terminate it. Then ensure it matches the token exactly, and that it's on its own line with no text before or after.

      ### Exceptions:

      None.

      ---
      Note that SC1041 and SC1042 swapped numbers after v0.4.6 to improve the display order. This rare instance of number reuse was justified by them always occuring together on the same line.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2078:
  remediation_points: 50000
  content:
    body: |
      ## This expression is constant. Did you forget a `$` somewhere?
      ### Problematic code:

      ```sh
      if [ "myvar" ]
      then
        echo "myvar is set"
      fi
      ```

      ### Correct code:

      ```sh
      if [ "$myvar" ]
      then
        echo "myvar is set"
      fi
      ```
      ### Rationale:

      ShellCheck has found a `[ .. ]` or `[[ .. ]]` statement that just contains a literal string. Such a check does not do anything useful, and will always be true (or always false, for empty strings).

      This is usually due to missing `$` or bad quoting:

          if [[ STY ]             # always true
          if [[ $STY ]]           # checks variable $STY

          if [[ 'grep foo bar' ]] # always true
          if [[ `grep foo bar` ]] # checks grep output (poorly)
          if grep -q foo bar      # checks for grep match (preferred)


      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2051:
  remediation_points: 50000
  content:
    body: "## Bash doesn't support variables in brace range expansions.\r\n\r\n###
      Problematic code:\r\n\r\n```bash\r\nfor i in {1..$n}\r\ndo\r\n  echo \"$i\"\r\ndone\r\n```\r\n\r\n###
      Correct code:\r\n\r\n```bash\r\nfor ((i=0; i<n; i++))\r\ndo\r\n  echo \"$i\"\r\ndone\r\n```\r\n\r\n###
      Rationale:\r\n\r\nIn Bash, brace expansion happens before variable expansion.
      This means that brace expansion will not account for variables.\r\n\r\nFor integers,
      use an arithmetic for loop instead. For zero-padded numbers or letters, use
      of eval may be warranted:\r\n\r\nfrom=\"a\" to=\"m\"\r\nfor c in $(eval \"echo
      {$from..$to}\"); do echo \"$c\"; done\r\n\r\nor more carefully (if `from`/`to`
      could be user input, or if the brace expansion could have spaces):\r\n\r\nfrom=\"a\"
      to=\"m\"\r\nwhile IFS= read -d '' -r c\r\ndo\r\n  echo \"Read $c\"\r\ndone <
      \ <(eval \"printf '%s\\0' $(printf \"{%q..%q}.jpg\" \"$from\" \"$to\")\")\r\n\r\n\r\n###
      Exceptions\r\n\r\nNone (if you're writing for e.g. zsh, make sure the shebang
      indicates this so shellcheck won't warn)\r\n\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2069:
  remediation_points: 50000
  content:
    body: |
      ## The order of the 2>&1 and the redirect matters. The 2>&1 has to be last.

      ### Problematic code:

      ```sh
      firefox 2>&1 > /dev/null
      ```

      ### Correct code:

      ```sh
      firefox > /dev/null 2>&1
      ```

      ### Rationale:

      Redirections are handled in order.

      The problematic code means "Point stderr to where stdout is currently pointing (the terminal). Then point stdout to /dev/null".

      The correct code means "Point stdout to /dev/null. Then point stderr to where stdout is currently pointing (/dev/null)".

      In other words, the problematic code hides stdout and shows stderr. The correct code hides both stderr and stdout, which is usually the intention.

      ### Exceptions

      If you want stderr as stdout and stdout to a file, you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1089:
  remediation_points: 50000
  content:
    body: |
      ## Parsing stopped here. Is this keyword correctly matched up?

      ### Problematic code:

      ```sh
      if true
      then
        echo hello
      fi
      fi
      ```

      ### Correct code:

      ```sh
      if true
      then
        echo hello
      fi
      ```

      ### Rationale:

      This error is typically seen when there are too many `fi`, `done` or `esac`s, or when there's a `do` or `then` without a corresponding `while`, `for` or `if`. This is often due to deleting a loop or conditional statement but not its terminator.

      In some cases, it can even be caused by bad quoting:

      ```sh
      var="foo
      if [[ $var = "bar ]
      then
        echo true
      fi
      ```

      In this case, the `if` ends up inside the double quotes, leaving the `then` dangling.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1014:
  remediation_points: 50000
  content:
    body: "## Use 'if cmd; then ..' to check exit code, or 'if [\\[ $(cmd) == .. ]]'
      to check output.\n\n### Problematic code:\n\n```sh\nif [ grep -q pattern file
      ]\nthen\n  echo \"Found a match\"\nfi\n```\n\n### Correct code:\n\n```sh\nif
      grep -q pattern file\nthen\n  echo \"Found a match\"\nfi\n\n```\n### Rationale:\n\n`[
      .. ]` is not part of shell syntax like `if` statements. It is not equivalent
      to parentheses in C-like languages, `if (foo) { bar; }`, and should not be wrapped
      around commands to test. \n\n`[` is just regular command, like `whoami` or `grep`,
      but with a funny name (see `ls -l /bin/[`). It's a shorthand for `test`. \n\nIf
      you want to check the exit status of a certain command, use that command directly
      as demonstrated in the correct code.\n\nIf you want to check the output of a
      command, use `\"$(..)\"` to get its output, and then use `test` or  `[`/`[[`
      to do a string comparison:\n\n```\n# Check output of `whoami` against the string
      `root`\nif [ \"$(whoami)\" = \"root\" ]\nthen\n  echo \"Running as root\"\nfi\n```\n\nFor
      more information, see [this problem in the Bash Pitfall](http://mywiki.wooledge.org/BashPitfalls#if_.5Bgrep_foo_myfile.5D)
      list, or generally [Tests and Conditionals](http://mywiki.wooledge.org/BashGuide/TestsAndConditionals)
      in the WoolEdge BashGuide \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2222:
  remediation_points: 50000
  content:
    body: |
      ## This pattern never matches because of a previous pattern.

      See companion warning [[SC2221]].

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1112:
  remediation_points: 50000
  content:
    body: |
      ## This is a unicode quote. Delete and retype it (or ignore/doublequote for literal).

      ### Problematic code:

      ```sh
      echo 'hello world’
      ```

      ### Correct code:

      ```sh
      echo 'hello world'
      ```

      ### Rationale:

      Some software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. The shell does not recognize these quotes and will not respect them.

      In this case, you have slanted single quotes in a single quoted string. Try deleting and retyping them, and/or disable “smart quotes” in your editor or OS.

      ### Exceptions

      If you want to use literal slanted single quotes for typographic reasons, you can put them in double quotes to make ShellCheck ignore them:

      ```sh
      printf "Warning: ‘wakeonlan’ is not installed.\\n"
      ```

      You can also just [[ignore]] this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2065:
  remediation_points: 50000
  content:
    body: |
      ## This is interpreted as a shell file redirection, not a comparison.

      ### Problematic code:

      ```sh
      [ 1 >2 ] || [ 3>'aaa bb' ] # Simple example of problematic code
      ```

      ### Correct code:

      ```sh
      [ 1 -gt 2 ] || [ 3 \> 'aaa bb' ] # arithmetical, lexicographical
      ```
      ### Rationale:

      A word that looks like a redirection in simple shell commands causes it to be interpreted as a redirection.
      ShellCheck would guess that you don't want it in tests.

      ### Exceptions:

      When it's among a continuous list of redirections at the end of a simple `test` command, it's more likely that
      the user really meant to do a redirection. Or any other case that you mean to do that.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1088:
  remediation_points: 50000
  content:
    body: |
      ## Parsing stopped here. Invalid use of parentheses?

      ### Problematic code:

      ```sh
      grep ^(.*)\1$ file
      ```

      or

      ```sh
      var = myfunction(value)
      ```

      ### Correct code:

      ```sh
      grep '^(.*)\1$' file
      ```

      or

      ```sh
      var=$(myfunction value)
      ```

      ### Rationale:

      Parentheses are shell syntax and must be used correctly.

      For commands that expect literal parentheses, such as `grep` or `find`, the parentheses need to be quoted or escaped so the shell does not interpret them, but instead passes them to the command.

      For shell syntax, the shell does not use them the way most other languages do, so avoid guessing at syntax based on previous experience. In particular:

      - Parentheses are NOT used to call functions.
      - Parentheses are NOT used to group expressions, except in arithmetic contexts.
      - Parentheses are NOT used in conditional statements or loops.
      - Parentheses are used differently in different contexts. `( .. )`, `$( .. )`, `$(( .. ))` and `var=(..)` are completely separate and independent structures with different meanings, and can not be broken down into operations on expressions in parentheses.

        In C-like languages, `++` can't be broken down into two `+` operations, so you can't e.g. use `+ +` or `+(+)`. In the same way, all of the above are completely unrelated so that you can't do `$(1+1)` or `$( (1+1) )` in place of `$(( 1+1 ))`.

      If you are trying to use parentheses for shell syntax, look up the actual syntax of the statement you are trying to use.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2182:
  remediation_points: 50000
  content:
    body: |
      ## This printf format string has no variables. Other arguments are ignored.

      ### Problematic code:

      ```sh
      place="world"
      printf hello $place
      ```

      ### Correct code:

      ```sh
      place="world"
      printf "hello %s\n" "$place"
      ```
      ### Rationale:

      ShellCheck has noticed that you're using a `printf` with multiple arguments, but where the first argument has no `%s` or equivalent variable placeholders.

      `echo` accepts zero or more strings to write, e.g. `echo hello world`.

      `printf` instead accepts one pattern/template with zero or more `%s`-style placeholders, and one argument for each placeholder.

      Rewrite your command using the right semantics, otherwise all arguments after the first one will be ignored:

          $ printf hello world\\n
          hello

          $ printf "hello world\n"
          hello world

          $ printf "hello %s\n" "world"
          hello world

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2022:
  remediation_points: 50000
  content:
    body: |
      # Note that unlike globs, o* here matches 'ooo' but not 'oscar'
      ### Problematic code:

      ```sh
      grep 'foo*'
      ```

      when wanting to match `food` and `foosball`, but not `mofo` or `keyfob`.

      ### Correct code:

      ```sh
      grep '^foo'
      ```

      ### Rationale:

      As a glob, `foo*` means "Any string starting with foo", e.g. `food` and `foosball`.

      As a regular expression, "foo*" means "f followed by 1 or more o's, anywhere", e.g. "mofo" or "keyfob".

      This construct is way more common as a glob than as a regex, so ShellCheck notifies you about it.

      ### Exceptions

      If you're aware of the above, you can ignore this message. If you'd like shellcheck to be quiet, use a [[directive]] or `'fo[o]*'`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2043:
  remediation_points: 50000
  content:
    body: |
      ## This loop will only ever run once for a constant value. Did you perhaps mean to loop over dir/*, $var or $(cmd)?"

      ### Problematic code:

      ```sh
      for var in value
      do
        echo "$var"
      done
      ```

      ### Correct code:

      Correct code depends on what you want to do.

      To iterate over files in a directory, instead of `for var in /my/dir` use:

      ```sh
      for var in /my/dir/* ; do echo "$var"; done
      ```

      To iterate over lines in a file or command output, use a while read loop instead:

      ```sh
      mycommand | while IFS= read -r line; do echo "$line"; done
      ```

      To iterate over *words* written to a command or function's stdout, instead of `for var in myfunction`, use

      ```sh
      for var in $(myfunction); do echo "$var"; done
      ```

      To iterate over *words* in a variable, instead of  `for var in myvariable`, use

      ```sh
      for var in $myvariable; do echo "$var"; done
      ```



      ### Rationale:

      ShellCheck has detected that your for loop iterates over a single, constant value. This is most likely a bug in your code, caused by you not expanding the value in the way you want.

      You should make sure that whatever you loop over will expand into multiple words.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2003:
  remediation_points: 50000
  content:
    body: |
      # expr is antiquated. Consider rewriting this using $((..)), ${} or \[\[ \]\].

      ### Problematic code:

      ```sh
      i=$(expr 1 + 2)
      l=$(expr length "$var")
      ```

      ### Correct code:

      ```sh
      i=$((1+2))
      l=${#var}
      ```

      ### Rationale:

      [To quote POSIX:](http://pubs.opengroup.org/onlinepubs/009695399/utilities/expr.html)

      > The expr utility has a rather difficult syntax [...] In many cases, the arithmetic and string features provided as part of the shell command language are easier to use than their equivalents in expr. Newly written scripts should avoid expr in favor of the new features within the shell.

      ### Exceptions

      `sh` doesn't have a great replacement for the `:` operator (regex match). ShellCheck tries not to warn when using expr with `:`, but e.g. `op=:; expr string "$op" regex` will still trigger it.

      Other than that, all uses of `expr` can be rewritten to use modern shell features instead.

      Bash has `[[ string =~ regex ]]`, so not even `expr .. : ..` is necessary.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2168:
  remediation_points: 50000
  content:
    body: |
      ## 'local' is only valid in functions.

      ### Problematic code:

      ```sh
      local foo=bar
      echo "$foo"
      ```

      ### Correct code:

      ```sh
      foo=bar
      echo "$foo"
      ```
      ### Rationale:

      In Bash, `local` can only be used in functions. In other contexts, it's an error.

      ### Exceptions:

      It's possible to source files containing `local` from a function context but not from any other context. This is not good practice, but in these cases you can [[ignore]] this error.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1095:
  remediation_points: 50000
  content:
    body: |
      ## You need a space or linefeed between the function name and body.

      ### Problematic code:

      ```sh
      function foo{
        echo "hello world"
      }
      ```

      ### Correct code:

      Prefer POSIX syntax:
      ```sh
      foo() {
        echo "hello world"
      }
      ```

      Alternatively, add the missing space between function name and opening `{`:
      ```sh
      #           v-- Here
      function foo {
        echo "hello world"
      }
      ```
      ### Rationale:

      When using `function` keyword function definitions without `()`, a space is required between the function name and the opening `{`.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2076:
  remediation_points: 50000
  content:
    body: |
      ## Don't quote rhs of =~, it'll match literally rather than as a regex.

      ### Problematic code:

      ```sh
      [[ $foo =~ "^fo+ bar$" ]]
      ```

      ### Correct code:

      ```sh
      [[ $foo =~ ^fo+\ bar$ ]]
      ```

      ### Rationale:

      Quotes on the right hand side of `=~` can be used to match literally, so that `[[ $1 =~ ^"$2".* ]]` works even if `$2` contains regex metacharacters. This mirrors the behavior of globs, `[[ $1 = "$2"* ]]`.

      This also means that the problematic code tries to match literal carets and plus signs instead of interpreting them as regular expression matchers.  To match as a regex, the regex metacharacters it must be unquoted. Literal parts of the expression can be quoted with double or single quotes, or escaped.

      ### Exceptions:

      If you do want to match literally just to do a plain substring search, e.g. `[[ $foo =~ "bar" ]]`, you could ignore this message, but consider using a more canonical glob match instead: `[[ $foo = *"bar"* ]]`.

      ### Compatibility:

      * In Bash 3.2 and newer with shopt `compat31` *disabled (the default)*, quoted patterns are literal whereas unquoted patterns are parsed for regex metacharacters.
      * In Bash 3.2 and newer with shopt `compat31` *enabled*, quoted and unquoted patterns match identically.
      * In Bash 3.1 quoted and unquoted patterns match identically.

      See http://stackoverflow.com/questions/218156/bash-regex-with-quotes


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1004:
  remediation_points: 50000
  content:
    body: |
      ## This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.

      ### Problematic code:

      ```sh
      var='This is long \
      piece of text'
      ```

      ### Correct code:

      ```sh
      var='This is a long '\
      'piece of text'
      ```
      ### Rationale:

      You have a single quoted string containing a backslash followed by a linefeed (newline). Unlike double quotes or unquoted strings, this has no special meaning. The string will contain a literal backslash and a linefeed.

      If you wanted to break the line but not add a linefeed to the string, stop the single quote, break the line, and reopen it. This is demonstrated in the correct code.

      If you wanted to break the line and also include the linefeed as a literal, you don't need a backslash:

      ```
      var='This is a multi-line string
      with an embedded linefeed'
      ```


      ### Exceptions:

      If you do want a string containing a literal backslash+linefeed combo, such as with `sed`, you can [[ignore]] this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2110:
  remediation_points: 50000
  content:
    body: |
      ## In [\[..]], use || instead of -o.

      ### Problematic code:

      ```sh
      [[ "$1" = "-v" -o "$1" = "-help" ]]
      ```

      ### Correct code:

      ```sh
      [[ "$1" = "-v" || "$1" = "-help" ]]
      ```

      ### Rationale:

      `-o` for logical OR is not supported in a `[[ .. ]]` expression. Use `||` instead.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1084:
  remediation_points: 50000
  content:
    body: |
      ## Use #!, not !#, for the shebang.

      ### Problematic code:

      ```sh
      !#/bin/sh
      echo "Hello World"
      ```

      ### Correct code:

      ```sh
      #!/bin/sh
      echo "Hello World"
      ```

      ### Rationale:

      The shebang has been accidentally swapped. The `#` should come first: `#!`, not `!#`.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2015:
  remediation_points: 50000
  content:
    body: |
      # Note that A && B || C is not if-then-else. C may run when A is true.

      ### Problematic code:

      ```sh
      [[ $dryrun ]] && echo "Would delete file" || rm file
      ```

      ### Correct code:

      ```sh
      if [[ $dryrun ]]
      then
        echo "Would delete file"
      else
        rm file
      fi
      ```

      ### Rationale:

      It's common to use `A && B` to run `B` when `A` is true, and `A || C` to run `C` when `A` is false.

      However, combining them into `A && B || C` is not the same as `if A then B else C`.

      In this case, if `A` is true but `B` is false, `C` will run.

      For the code sample above, if the script was run with stdout closed for any reason (such as explicitly running `script --dryrun >&-`), echo would fail and the file would be deleted, even though `$dryrun` was set!

      If an `if` clause is used instead, this problem is avoided.

      ### Exceptions
      Ignore this warning when you actually do intend to run C when either A or B fails.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2032:
  remediation_points: 50000
  content:
    body: |
      # Use own script or sh -c '..' to run this from su.

      See [[SC2033]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1075:
  remediation_points: 50000
  content:
    body: "## Use 'elif' instead of 'else if'.\n\n### Problematic code:\n\n```sh\nif
      [ \"$#\" -eq 0 ]\nthen\n  echo \"Usage: ...\"\nelse if [ \"$#\" -lt 2 ]\nthen\n
      \ echo \"Missing operand\"\nfi\n  \n```\n\n### Correct code:\n\n```sh\nif [
      \"$#\" -eq 0 ]\nthen\n  echo \"Usage: ...\"\nelif [ \"$#\" -lt 2 ]\nthen\n  echo
      \"Missing operand\"\nfi\n```\n### Rationale:\n\nMany languages allow alternate
      branches with `else if`, but `sh` is not one of them. Use `elif` instead.\n\n###
      Exceptions:\n\n`else if` is a valid (though confusing) way of nesting an `if`
      statement in a parent's `else`. If this is your intention, please use canonical
      formatting and put a linefeed between `else` and `if`. \n\n```sh\n\nif x\nthen\n
      \ echo \"x\"\nelse     # line break here\n  if y\n  then\n    echo \"y\"\n   fi
      \nfi\n```\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2009:
  remediation_points: 50000
  content:
    body: |
      ## SC2009 Consider using pgrep instead of grepping ps output.

      ### Problematic Code:

      ```sh
      ps ax | grep -v grep | grep "$service" > /dev/null
      ```

      ### Correct Code:

      ```sh
      pgrep -f "$service" > /dev/null
      ```

      ### Rationale:

      If you are just after a pid from a running program, then pgrep is a much safer alternative. Especially if you are also looking for a pid belonging to a certain user or group. All of the parameters are in one command and it can eliminate multiple greps, cuts, seds, awks, ect.

      ### Exceptions

      What if you have the pid and you are looking for the matching program name?

      ```sh
      pid=123; ps ax | grep "$pid"
      ```

      What if you want a range of the ps field, like from the 16th space to the end of the line?

      ```sh
      ps ax | grep "$pid" | cut -d" " -f16-
      ```

      Both are valid cases where SC2009 is not valid.



      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2048:
  remediation_points: 50000
  content:
    body: |
      ## Use "$@" (with quotes) to prevent whitespace problems.

      ### Problematic code:

      ```sh
      cp $* ~/dir
      ```

      ### Correct code:

      ```sh
      cp "$@" ~/dir
      ```

      ### Rationale:

      `$*`, unquoted, is subject to word splitting and globbing.

      Let's say you have three arguments: `baz`, `foo bar` and `*`

      `"$@"` will expand into exactly that: `baz`, `foo bar` and `*`

      `$*` will expand into multiple other arguments: `baz`, `foo`, `bar`, `file.txt` and `otherfile.jpg`

      Since the latter is rarely expected or desired, ShellCheck warns about it.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2161:
  remediation_points: 50000
  content:
    body: |
      ## Instead of '[ 1 ]', use 'true'.

      ### Problematic code:

      ```sh
      while [ 1 ]
      do
        echo "infinite loop"
      done
      ```

      ### Correct code:

      ```sh
      while true
      do
        echo "infinite loop"
      done
      ```

      ### Rationale:

      This is a stylistic suggestion to use `true` instead of `[ 1 ]`.

      `[ 1 ]` seems to suggest that the value "1" is somehow relevant to the statement. This is not the case: it doesn't matter. You can replace it with `[ 0 ]` or `[ wombat ]`, and it will still always be true.

      If you instead use `true`, the value is actually considered and can be inverted by replacing with `false`.

      On bash, you can also use `(( 1 ))`, which evaluates to true much like in C. `(( 0 ))` is similarly false.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2173:
  remediation_points: 50000
  content:
    body: |
      ## SIGKILL/SIGSTOP can not be trapped.

      ### Problematic code:

      ```sh
      trap 'echo "unkillable"' KILL
      ```

      ### Correct code:

      Not applicable. This is not possible.

      ### Rationale:

      SIGKILL and SIGSTOP can not be caught/ignored (according to POSIX and as implemented on platforms including Linux and FreeBSD). Trying to trap this signal has undefined results.

      ### Exceptions:

      None. If you come across one, please file an issue about it.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2082:
  remediation_points: 50000
  content:
    body: |
      ## To expand via indirection, use name="foo$n"; echo "${!name}".

      ### Problematic code:

      ```sh
      var_1="hello world"
      n=1
      echo "${var_$n}"
      ```

      ### Correct code:

      Bash/ksh:

      ```sh
      # Use arrays instead of dynamic names
      declare -a var
      var[1]="hello world"
      n=1
      echo "${var[n]}"
      ```

      or

      ```sh
      # Expand variable names dynamically
      var_1="hello world"
      n=1
      name="var_$n"
      echo "${!name}"
      ```

      POSIX sh:

      ```sh
      # Expand dynamically with eval
      var_1="hello world"
      n=1
      eval "tmp=\$var_$n"
      echo "${tmp}"
      ```

      ### Rationale:

      You can expand a variable `var_1` with `${var_1}`, but you can not generate the string `var_1` with an embedded expansion, like `${var_$n}`.

      Instead, if at all possible, you should use an array. Bash and ksh support both numerical and associative arrays, and an example is shown above.

      If you can't use arrays, you can indirectly reference variables by creating a temporary variable with its name, e.g. `myvar="var_$n"` and then expanding it indirectly with `${!myvar}`. This will give the contents of the variable `var_1`.

      If using POSIX sh, where neither arrays nor `${!var}` is available, `eval` can be used. You must be careful in sanitizing the data used to construct the variable name to avoid arbitrary code execution.

      ### Exceptions:

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1040:
  remediation_points: 50000
  content:
    body: |
      ## When using <<-, you can only indent with tabs.

      ### Problematic code:

      Any code using `<<-` that is indented with spaces. `cat -T script` shows

      ```sh
          cat <<- foo
              Hello world
          foo
      ```

      ### Correct code:

      Code using `<<-` must be indented with tabs. `cat -T script` shows

      ```sh
      ^Icat <<- foo
      ^I^IHello world
      ^Ifoo
      ```

      Or simply don't indent the end token:

      ```sh
          cat <<- foo
            Hello World
      foo
      ```

      ### Rationale:

      `<<-`, by design, only strips tabs. Not spaces.

      Your editor may be automatically replacing tabs with spaces, either when you type them or when you save the file or both. If you're unable to make it stop, just don't indent the end token.

      ### Exceptions

      None. But note that copy-pasting code to [shellcheck.net](http://www.shellcheck.net) may also turn correct tabs into spaces on some OS.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2177:
  remediation_points: 50000
  content:
    body: |
      ## 'time' is undefined for compound commands, time sh -c instead.

      ### Problematic code:

      ```sh
      time for i in *.bmp; do convert "$i" "$i.png"; done
      ```

      ### Correct code:

      ```sh
      time sh -c 'for i in *.bmp; do convert "$i" "$i.png"; done'
      ```
      ### Rationale:

      `time` is only defined for Simple Commands [by POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/time.html). Timing loops, command groups and similar is not.

      ### Exceptions:

      None. If you use a shell that supports this (e.g. bash, ksh), specify this shell in the shebang.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2061:
  remediation_points: 50000
  content:
    body: "## Quote the parameter to -name so the shell won't interpret it.\n\n###
      Problematic code:\n\n```sh\nfind . -name *.txt\n```\n\n### Correct code:\n\n```sh\nfind
      . -name '*.txt'\n```\n### Rationale:\n\nSeveral find options take patterns to
      match against, including `-ilname`, `-iname`, `-ipath`, `-iregex`, `-iwholename`,
      `-lname`, `-name`, `-path`, `-regex` and `-wholename`.\n\nThese compete with
      the shell's pattern expansion, and must therefore be quoted so that they are
      passed literally to `find`.\n\nThe example command may end up executing as `find
      . -name README.txt` after the shell has replaced the `*.txt` with a matching
      file `README.txt` from the current directory. \n\nThis may happen today or suddenly
      in the future.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1126:
  remediation_points: 50000
  content:
    body: "## Place shellcheck directives before commands, not after.\n\n### Problematic
      code:\n\n```sh\nvar=1 # shellcheck disable=SC2034\n```\n\n### Correct code:\n\n```sh\n#
      shellcheck disable=SC2034\nvar=1 \n```\n### Rationale:\n\nShellCheck expects
      directives to come before the relevant command. They are not allowed after.\n\n###
      Exceptions:\n\nIf this is not a directive and just a comment mentioning ShellCheck,
      please rewrite or capitalize:\n\n    var=1 # ShellCheck encourages lowercase
      variable names\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2034:
  remediation_points: 50000
  content:
    body: |
      # foo appears unused. Verify it or export it.

      ### Problematic code:

      ```sh
      foo=42
      echo "$FOO"
      ```

      ### Correct code:

      ```sh
      foo=42
      echo "$foo"
      ```

      ### Rationale:

      Variables not used for anything are often associated with bugs, so ShellCheck warns about them.

      Also note that something like `local let foo=42` does not make a `let` statement local -- it instead declares an additional local variable named `let`.

      ### Exceptions

      ShellCheck may not always realize that the variable is in use (especially with indirection), and may not realize you don't care (with throwaway variables or unimplemented features).

      For throwaway variables, consider using `_` as a dummy:

      ```sh
      read _ last _ zip _ _ <<< "$str"
      echo "$last, $zip"
      ```

      or use a directive to disable the warning:

      ```sh
      # shellcheck disable=SC2034
      read first last email zip lat lng <<< "$str"
      echo "$last, $zip"
      ```

      For indirection, there's not much you can do without rewriting to use arrays or similar:

      ```sh
      bar=42  # will always appear unused
      foo=bar
      echo "${!foo}"
      ```

      This is expected behavior, and not a bug. There is no good way to statically analyze indirection in shell scripts, just like static C analyzers have a hard time preventing segfaults.

      As always, there are ways to [[ignore]] this and other messages if they frequently get in your way.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2025:
  remediation_points: 50000
  content:
    body: |
      # Make sure all escape sequences are enclosed in \[..\] to prevent line wrapping issues

      ### Problematic code:

      ```sh
      PS1='\e[36m\$ \e(B\e[m'
      ```

      ### Correct code:

      ```sh
      PS1='\[\e[36m\]\$ \[\e(B\e[m\]'
      ```

      ### Rationale:

      Bash is unable to determine exactly which parts of your prompt are text and which are terminal codes. You have to help it by wrapping invisible control codes in `\[..\]` (and ensuring that visible characters are not wrapped in `\[..\]`).

      Note: ShellCheck offers this as a helpful hint and not a robust check. Don't rely on ShellCheck to verify that your prompt is correct.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1121:
  remediation_points: 50000
  content:
    body: "## Add ;/& terminators (and other syntax) on the line with the <<, not
      here.\n\n### Problematic code:\n\n```sh\nsudo bash -s << \"END\"\n  cmd1\n  cmd2\nEND
      &\n\n```\n\n### Correct code:\n\n```sh\nsudo bash -s << \"END\" &\n  cmd1\n
      \ cmd2\nEND\n```\n### Rationale:\n\nYou are using `&`, `;`, `&>` or similar
      after a here document. This is not allowed.\n\nThis should instead be part of
      the line that initiated the here document, i.e. the one with the `<<`. \n\nIf
      it helps, look at `<< \"END\"` as if it was `< file`, and make sure the resulting
      command is valid. This is what the shell does. You can then append here document
      data after the command.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2145:
  remediation_points: 50000
  content:
    body: |
      ## Argument mixes string and array. Use * or separate argument.

      ### Problematic code:

      ```sh
      printf "Error: %s\n" "Bad parameters: $@"
      ```

      ### Correct code:

      ```sh
      printf "Error: %s\n" "Bad parameters: $*"
      ```

      ### Rationale:

      The behavior when concatenating a string and array is rarely intended. The preceeding string is prefixed to the first array element, while the succeeding string is appended to the last one. The middle array elements are unaffected.

      E.g., with the parameters `foo`,`bar`,`baz`, `"--flag=$@"` is equivalent to the three arguments `"--flag=foo" "bar" "baz"`.

      If the intention is to concatenate all the array elements into one argument, use `$*`. This concatenates based on `IFS`.

      If the intention is to provide each array element as a separate argument, put the array expansion in its own argument.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2006:
  remediation_points: 50000
  content:
    body: |
      # Use $(STATEMENT) instead of legacy \`STATEMENT\`

      ### Problematic code

      ```sh
      echo "Current time: `date`"
      ```

      ### Correct code

      ```sh
      echo "Current time: $(date)"
      ```

      ### Rationale

      Backtick command substitution `` `STATEMENT` `` is legacy syntax with several issues.

      1. It has a series of undefined behaviors related to quoting in POSIX.
      1. It imposes a custom escaping mode with surprising results.
      1. It's exceptionally hard to nest.

      `$(STATEMENT)` command substitution has none of these problems, and is therefore strongly encouraged.

      ### Exceptions

      None.

      ### See also

      - http://mywiki.wooledge.org/BashFAQ/082


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2060:
  remediation_points: 50000
  content:
    body: |
      # Quote parameters to tr to prevent glob expansion.

      ### Problematic code:

      ```sh
      tr -cd [:digit:]
      ```

      ### Correct code:

      ```sh
      tr -cd '[:digit:]'
      ```

      ### Rationale:

      `[:digit:]` is a shell glob that matches any single character file named e.g. `g` or `t` in the current directory. Quoting it prevents the script from breaking in directories with files like this.

      ### Exceptions

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1003:
  remediation_points: 50000
  content:
    body: |
      ## Want to escape a single quote? echo 'This is how it'\\''s done'.

      (Note: in v0.4.6, the error message was accidentally missing the backslash)

      ### Problematic code:

      ```sh
      echo 'This is not how it\'s done'.
      ```

      ### Correct code:

      ```sh
      echo 'This is how it'\''s done'.
      ```


      ### Rationale

      In POSIX shell, the shell cares about nothing but another single quote to terminate the quoted segment. Not even backslashes are interpreted.

      [POSIX.1 Shell Command Language § 2.2.2 Single Quotes](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_02):

      > Enclosing characters in single-quotes ( `''` ) shall preserve the literal value of each character within the single-quotes. A single-quote cannot occur within single-quotes.

      ### Exceptions
      If you want your single quoted string to end in a backslash, you can rewrite as `'string'\\` or [[ignore]] this warning.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2087:
  remediation_points: 50000
  content:
    body: |
      ## Quote 'EOF' to make here document expansions happen on the server side rather than on the client.

      ### Problematic code:

      ```sh
      ssh host.example.com << EOF
        echo "Logged in on $HOSTNAME"
      EOF
      ```

      ### Correct code:

      ```sh
      ssh host.example.com << "EOF"
        echo "Logged in on $HOSTNAME"
      EOF
      ```

      ### Rationale:

      When the end token of a here document is unquoted, parameter expansion and command substitution will happen on in contents of the here doc.

      This means that before sending the commands to the server, the client replaces `$HOSTNAME` with localhost, thereby sending `echo "Logged in on localhost"` to the server. This has the effect of printing the client's hostname instead of the server's.

      Scripts with any kind of variable use are especially problematic because all references will be expanded before the script run. For example,

      ```sh
      ssh host << EOF
        x="$(uname -a)"
        echo "$x"
      EOF
      ```

      will never print anything, neither client nor server details, since before evaluation, it will be expanded to:

      ```sh
        x="Linux localhost ... x86_64 GNU/Linux"
        echo ""
      ```

      By quoting the here token, local expansion will not take place, so the server sees `echo "Logged in on $HOSTNAME"` which is expanded and printed with the server's hostname, which is usually the intention.

      ### Exceptions:

      If the client should expand some or all variables, this message can and should be ignored.

      To expand a mix of local and remote variables, the here doc end token should be unquoted, and the remote variables should be escaped, e.g.

      ```sh
      ssh host.example.com << EOF
        echo "Logged in on \$HOSTNAME from $HOSTNAME"
      EOF
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2208:
  remediation_points: 50000
  content:
    body: "## Use `[[ ]]` or quote arguments to -v to avoid glob expansion.\n\n###
      Problematic code:\n\n```sh\n[ -v foo[0] ] \n```\n\n### Correct code:\n\n```sh\n[
      -v 'foo[0]' ]\n```\n### Rationale:\n\nWith `[`, arguments will undergo glob
      expansion. If a file `foo0` exists when the problematic code is run, it will
      check for the variable `foo0` instead of the array entry `foo[0]`. If there
      additionally exists a `foo1`, it will simply fail with an error.\n\nUse `[[
      ]]` or quote the argument.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2164:
  remediation_points: 50000
  content:
    body: |
      ## Use cd ... || exit in case cd fails.

      ### Problematic code:

      ```sh
      cd generated_files
      rm -r *.c

      func(){
        cd foo
        do_something
      }
      ```

      ### Correct code:

      ```sh
      cd generated_files || exit
      rm -r *.c

      # For functions, you may want to use return:
      func(){
        cd foo || return
        do_something
      }
      ```

      ### Rationale:

      `cd` can fail for a variety of reasons: misspelled paths, missing directories, missing permissions, broken symlinks and more.

      If/when it does, the script will keep going and do all its operations in the wrong directory. This can be messy, especially if the operations involve creating or deleting a lot of files.

      To avoid this, make sure you handle the cases when `cd` fails. Ways to do this include

      * `cd foo || exit` as suggested to just abort immediately
      * `if cd foo; then echo "Ok"; else echo "Fail"; fi` for custom handling
      * `<(cd foo && cmd)` as an alternative to `<(cd foo || exit; cmd)` in `<(..)`, `$(..)` or `( )`

      ### Exceptions:

      ShellCheck does not give this warning when `cd` is on the left of a `||` or `&&`, or the condition of a `if`, `while` or `until` loop. Having a `set -e` command anywhere in the script will disable this message, even though it won't necessarily prevent the issue.

      If you are accounting for `cd` failures in a way shellcheck doesn't realize, you can disable this message with a [[directive]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2156:
  remediation_points: 50000
  content:
    body: |
      ## Injecting filenames is fragile and insecure. Use parameters.

      ### Problematic code:

      ```sh
      find . -name '*.mp3' -exec sh -c 'i="{}"; sox "$i" "${i%.mp3}.wav"' \;
      ```

      ### Correct code:

      ```sh
      find . -name '*.mp3' -exec sh -c 'i="$1"; sox "$i" "${i%.mp3}.wav"' _ {} \;
      ```

      ### Rationale:

      In the problematic example, the filename is passed by injecting it into a shell string. Any shell metacharacters in the filename will be interpreted as part of the script, and not as part of the filename. This can break the script and allow arbitrary code execution exploits.

      In the correct example, the filename is passed as a parameter. It will be safely treated as literal text. The `_` is a dummy string that becomes `$0` in the script.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1007:
  remediation_points: 50000
  content:
    body: |
      # Remove space after = if trying to assign a value (or for empty string, use var='' ... ).

      ### Problematic code:

      ```sh
      # I want programs to show text in dutch!
      LANGUAGE= nl
      ```

      ```sh
      # I want to run the nl command with English error messages!
      LANGUAGE= nl
      ```

      ### Correct code:

      ```sh
      # I want programs to show text in dutch!
      LANGUAGE=nl
      ```

      ```sh
      # I want to run the nl command with English error messages!
      LANGUAGE='' nl
      ```

      ### Rationale:

      It's easy to think that `LANGUAGE= nl` would assign `"nl"` to the variable `LANGUAGE`. It doesn't.

      Instead, it runs `nl` (the "number lines" command) and sets `LANGUAGE` to an empty string in its environment.

      Since trying to assign values this way is a common mistake, ShellCheck warns about it and asks you to be explicit when assigning empty strings (except for `IFS`, due to the common `IFS= read ..` idiom).

      ### Exceptions
      If you're familiar with this behavior and feel that the explicit version is unnecessary, you can [[ignore]] it.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2165:
  remediation_points: 50000
  content:
    body: |
      ## This nested loop overrides the index variable of its parent.

      And companion warning "This parent loop has its index variable overridden."

      ### Problematic code:

      ```sh
      for((i=0; i<10; i++))
      do
        for i in *
        do
          echo "$i"
        done
      done
      ```

      ### Correct code:

      ```sh
      for((i=0; i<10; i++))
      do
        for j in *
        do
          echo "$j"
        done
      done
      ```

      ### Rationale:

      When nesting loops, especially arithmetic for loops, using the same loop variable can cause unexpected results.

      In the problematic code, `i` will contain the last filename from the inner loop, which will be interpreted as a value in the next iteration out the outer loop. This results in either an infinite loop or a syntax error, depending on whether the last filename is a valid shell variable name.

      In nested for-in loops, variable merely shadow each other and won't cause infinite loops or syntax errors, but reusing the variable name is rarely intentional.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2170:
  remediation_points: 50000
  content:
    body: |
      ## Numerical -eq does not dereference in [..]. Expand or use string operator.

      ### Problematic code:

      ```sh
      read -r n
      if [ n -lt 0 ]
      then
         echo "bad input"
      fi
      ```

      ### Correct code:

      ```sh
      read -r n
      if [ "$n" -lt 0 ]
      then
         echo "bad input"
      fi
      ```
      ### Rationale:

      You are comparing a string value with a numerical operator, such as `-eq`, `-ne`, `-lt` or `-gt`.

      In `[[ .. ]]`, this would automatically dereference the string, looking to see if there are variables by that name.

      In `[ .. ]`, which you are using, the string is just treated as an invalid number.

      If you want to compare numbers, expand yourself (e.g. use `$var` instead of `var`). If you are trying to compare strings and not numbers, use `=`, `!=` `\<` or `\>` instead.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2219:
  remediation_points: 50000
  content:
    body: "## Instead of `let expr`, prefer `(( expr ))` .\n\n### Problematic code:\n\n```sh\nlet
      a++\n```\n\n### Correct code:\n\n```sh\n(( a++ ))\n```\n### Rationale:\n\nThe
      `(( .. ))` arithmetic compound command evaluates expressions in the same way
      as `let`, except it's not subject to glob expansion and therefore requires no
      additional quoting or escaping. \n\nThis warning only triggers in Bash/Ksh scripts.
      In Sh/Dash, neither `let` nor `(( .. ))` are defined, but can be simulated with
      `[ $(( expr )) -ne 0 ]` to retain exit code, or `: $(( expr ))` to ignore it.\n\n###
      Exceptions:\n\nNone.\n\n### More information\n\n* Bash Hacker's Wiki: [The let
      builtin command](http://wiki.bash-hackers.org/commands/builtin/let)\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1123:
  remediation_points: 50000
  content:
    body: "## ShellCheck directives are only valid in front of complete compound commands,
      like `if`, not e.g. individual `elif` branches.\n\n### Problematic code:\n\n```sh\nif
      [ \"$prod\" = \"true\" ]\nthen\n  echo \"Prod mode\"\n# shellcheck disable=2154\nelif
      [ \"$debug\" = \"true\" ]\nthen\n  echo \"Debug mode\"\nfi\n```\n\n### Correct
      code:\n```sh\n# Applies to entire `if...fi` command\n# shellcheck disable=2154\nif
      [ \"$prod\" = \"true\" ]\nthen\n  echo \"Prod mode\"\nelif [ \"$debug\" = \"true\"
      ]\nthen\n  echo \"Debug mode\"\nfi\n```\n\nor \n\n```sh\nif [ \"$prod\" = \"true\"
      ]\nthen\n  echo \"Prod mode\"\nelif  # Applies only to this [ .. ] command\n
      \     # shellcheck disable=2154\n      [ \"$debug\" = \"true\" ]\nthen\n  echo
      \"Debug mode\"\nfi\n```\n\n\n### Rationale:\n\nYou appear to have put a directive
      before a non-command keyword, such as `elif`, `else`, `do`, `;;` or similar.
      \n\nUnlike many other linters, ShellCheck comment directives apply to the next
      shell command, rather than to the next line of text.\n\nThis means that you
      can put a directive in front of a `while` loop, `if` statement or function definition,
      and it will apply to that entire structure.\n\nHowever, it also means that you
      can not apply the directive to non-commands like an individual `elif` or `else`
      block since these are not commands by themselves, and rather just parts of an
      `if` compound command.\n\nPlease move the directive in front of the nearest
      applicable command that contains the code you want to apply it to, such as before
      the `if`. \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from
      the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2018:
  remediation_points: 50000
  content:
    body: "## Use '[:lower:]' to support accents and foreign alphabets.\n\n### Problematic
      code:\n\n```sh\nPLATFORM=\"$(uname -s | tr 'A-Z' 'a-z')\"\n```\n\n### Correct
      code:\n\n```sh\nPLATFORM=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\n```\n\n###
      Rationale:\n\n`A-Z` and `a-z` are commonly intended to mean \"all uppercase\"
      and \"all lowercase letters\" respectively. This ignores accented characters
      in English, and foreign characters in other languages:\n\n    $ tr 'a-z' 'A-Z'
      <<< \"My fiancée ordered a piña colada.\"\n    MY FIANCéE ORDERED A PIñA COLADA.\n\nInstead,
      you can use `[:lower:]` and `[:upper:]` to explicitly specify case:\n\n    $
      tr '[:lower:]' '[:upper:]' <<< \"My fiancée ordered a piña colada.\"\n    MY
      FIANCÉE ORDERED A PIÑA COLADA.\n\n### Exceptions:\n\nIf you don't want `a-z`
      to match `é` or `A-Z` to match `Ñ`, you can ignore this message.\n\nNote that
      the examples used here are multibyte characters in UTF-8. Many implementations
      (including GNU) fails to deal with them. \n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2218:
  remediation_points: 50000
  content:
    body: "## This function is only defined later. Move the definition up.\n\n###
      Problematic code:\n\n```sh\n#!/bin/sh\nmyfunction\n\nmyfunction() {\n  echo
      \"Hello World\"\n}\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\nmyfunction()
      {\n  echo \"Hello World\"\n}\nmyfunction\n```\n\n### Rationale:\n\nYou are calling
      a function that you are defining later in the file. The function definition
      must come first.\n\nFunction definitions are much like variable assignments,
      and define a name at the point the definition is \"executed\". This is why they
      must happen before their first use.\n\nThis is especially apparent when defining
      functions conditionally:\n\n```\ncase \"$(uname -s)\" in\n  Linux) hi() { echo
      \"Hello from Linux\"; } ;;\n  Darwin) hi() { echo \"Hello from macOS\"; } ;;\n
      \ *) hi() { echo \"Hello from something else\"; } ;;\nesac\n\nhi\n```\n\n\n###
      Exceptions:\n\nNone. \n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC2179:
  remediation_points: 50000
  content:
    body: |
      ## Use array+=("item") to append items to an array.

      ### Problematic code:

      ```sh
      var=(one two)
      var+=three
      ```

      ### Correct code:

      ```sh
      var=(one two)
      var+=( three )
      ```
      ### Rationale:

      It looks like you are trying to append a string to an array with `var+=string`. This instead appends to the first element of the array (equivalent to `var[0]+=three`).

      In the problematic code, the array will therefore contain `onethree` `two`.

      Instead, append an array to the array with `var+=( elements )`. This will append the new items to the array.

      In the correct code, it will contain `one` `two` `three` as expected.

      ### Exceptions:

      If ShellCheck mistakenly thinks the variable is an array when it's not (e.g. because the same name was used in a different context), you can ignore this error.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2200:
  remediation_points: 50000
  content:
    body: "## Brace expansions don't work as operands in [ ]. Use a loop.\n\n### Problematic
      code:\n\n```sh\n[ \"$file\" = index.{htm,html,php} ] && echo \"This is the main
      file\"\n\n```\n\n### Correct code:\n\n```sh\nfor main in index.{htm,html,php}\ndo\n
      \ [ \"$file\" = \"$main\" ] && echo \"This is the main file\"\ndone\n```\n\n###
      Rationale:\n\nBrace expansions in `[ ]` will expand to a sequence of words.
      Operators work on single words.\n\nThe problematic code is equivalent to `[
      \"$file\" = index.htm index.html index.php ]`, which is invalid syntax. A typical
      error message is `bash: [: too many arguments` or `dash: somefile: unexpected
      operator`. \n\nInstead, use a `for` loop to iterate over values, and apply your
      condition to each.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1015:
  remediation_points: 50000
  content:
    body: |
      ## This is a unicode double quote. Delete and retype it.

      ### Problematic code:

      ```sh
      echo “hello world”
      ```

      ### Correct code:

      ```sh
      echo "hello world"
      ```

      ### Rationale:

      Blog software and word processors frequently replaces ASCII quotes `""` with fancy Unicode quotes, `“”`. To bash, Unicode quotes are considered regular literals and not quotes at all.

      Simply delete them and retype them in your editor.

      ### Status:

      This error was retired after 0.4.5. In this version and earlier, ShellCheck parsed slanted quotes as a valid double quote. This meant that the warning could not simply be ignored. It has since been replaced by [[SC1110]] (outside quotes) and [[SC1111]] (inside double quotes).

      ### Exceptions

      If you really want literal Unicode double quotes, you can put them in single quotes (or Unicode single quotes in double quotes) to make shellcheck ignore them, e.g.,

      ```sh
      printf 'Warning: “wakeonlan” is not installed.\n'
      ```

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1049:
  remediation_points: 50000
  content:
    body: "## Did you forget the 'then' for this 'if'?\n\n### Problematic code:\n\n```sh\nif
      true\n  echo \"foo\"\nelif true\n  echo \"bar\"\nfi\n```\n\n### Correct code:\n\n```sh\nif
      true\nthen\n  echo \"foo\"\nelif true\nthen\n  echo \"bar\"\nfi\n```\n\n###
      Rationale:\n\nShellCheck found a parsing error in the script, and determined
      that it's most likely due to a missing `then` keyword for the `if` or `elif`
      indicated.\n\nMake sure the `then` is there. \n\nNote that the `then` needs
      a `;` or linefeed before it. `if true then` is invalid, while `if true; then`
      is correct.\n\n### Exceptions:\n\nNone\n\n### Notice\n\nOriginal content from
      the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2089:
  remediation_points: 50000
  content:
    body: |
      # Quotes/backslashes will be treated literally. Use an array.

      ### Problematic code:

      ```sh
      args='-lh "My File.txt"'
      ls $args
      ```

      ### Correct code:

      ```sh
      args=(-lh "My File.txt")
      ls "${args[@]}"
      ```

      ### Rationale:

      Bash does not interpret data as code. Consider almost any other languages, such as Python:

      ```sh
      print 1+1   # prints 2
      a="1+1"
      print a     # prints 1+1, not 2
      ```

      Here, `1+1` is Python syntax for adding numbers. However, passing a literal string containing this expression does not cause Python to interpret it, see the `+` and produce the calculated result.

      Similarly, `"My File.txt"` is Bash syntax for a single word with a space in it. However, passing a literal string containing this expression does not cause Bash to interpret it, see the quotes and produce the tokenized result.

      The solution is to use an array instead, whenever possible.

      If due to `sh` compatibility you can't use arrays, you can use `eval` instead. However, this is very insecure and easy to get wrong, leading to various forms of security vulnerabilities and breakage:

      ```sh
      quote() { local q=${1//\'/\'\\\'\'}; echo "'$q'"; }
      args="-lh $(quote "My File.txt")"
      eval ls "$args" # Do not use unless you understand implications
      ```

      If you ever accidentally forget to use proper quotes, such as with:

      ```sh
      for f in *.txt; do
        args="-lh '$1'" # Example security exploit
        eval ls "$args" # Do not copy and use
      done
      ```

      Then you can use `touch "'; rm -rf \$'\x2F'; '.txt"`  (or someone can trick you into downloading a file with this name, or create a zip file or git repo containing it, or changing their nick and have your chat client create the file for a chat log, or...), and running the script to list your files will run the command `rm -rf /`.

      ### Exceptions

      Few and far between.

      ### Additional resources

      [Wooledge BashFAQ #50](http://mywiki.wooledge.org/BashFAQ/050): I'm trying to put a command in a variable, but the complex cases always fail!

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1114:
  remediation_points: 50000
  content:
    body: "## Remove leading spaces before the shebang.\n\n### Problematic code:\n\n```sh\n
      \ #!/bin/sh\necho \"Hello world\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho
      \"Hello World\"\n```\n### Rationale:\n\nThe script has leading spaces before
      the shebang (`#!`). This is not allowed. \n\nThe `#!` should be the first two
      bytes in the file, as they're used as a file signature by the OS to determine
      whether a file is a script.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2072:
  remediation_points: 50000
  content:
    body: |
      ## Decimals are not supported. Either use integers only, or use bc or awk to compare.

      ### Problematic code:

      ```sh
      [[ 2 -lt 3.14 ]]
      ```

      ### Correct code:

      ```sh
      [[ 200 -lt 314 ]]                   # Use fixed point math
      [[ $(echo "2 &lt; 3.14" | bc) == 1 ]]  # Use bc
      ```

      ### Rationale:

      Bash and Posix sh does not support decimals in numbers. Decimals should either be avoided, or compared using a tool that does support them.

      ### Exceptions

      If the strings happen to be version numbers and you're using `<`, or `>` to compare them as strings, and you consider this an acceptable thing to do, then you can ignore this warning.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2010:
  remediation_points: 50000
  content:
    body: |
      ## Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.

      ### Problematic code:

      ```sh
      ls /directory | grep target_file_pattern
      ```

      ### Correct code:

      ```sh
      ls /directory/target_file_pattern
      ```
      ### Rationale:

      Matching non-alphanumeric characters with grep may require escaping.  Typically it is cleaner to use the built in pattern matching or another command like `find`

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2031:
  remediation_points: 50000
  content:
    body: |
      # var was modified in a subshell. That change might be lost.

      ### Problematic code:

      There are many ways of accidentally creating subshells, but a common one is piping to a loop:

      ```bash
      n=0
      printf "%s\n" {1..10} | while read i; do (( n+=i )); done
      echo $n
      ```

      ### Correct code:

      ```bash
      # Bash specific: process substitution. Also try shopts like lastpipe.
      n=0
      while read i; do (( n+=i )); done < <(printf "%s\n" {1..10})
      echo $n
      ```

      In `sh`, a temp file (better if fifo or fd) can be used instead of process substitution. And if it's acceptable to do it with waiting, try Here Documents.

      ### Rationale:

      Variables set in subshells are not available outside the subshell. This is a wide topic, and better described on the [Wooledge Bash Wiki](http://mywiki.wooledge.org/BashFAQ/024).

      Here are some constructs that cause subshells (shellcheck may not warn about all of them). In each case, you can replace `subshell1` by a command or function that sets a variable, e.g. simply `var=foo`, and the variable will appear to be unset after the command is run. Similarly, you can replace `regular` with `var=foo`, and it will be set afterwards:

      Pipelines:

      ```sh
      subshell1 | subshell2 | subshell3    # Bash, Dash, Ash
      subshell1 | subshell2 | regular      # Ksh, Zsh
      ```

      Command substitution:

      ```sh
      regular "$(subshell1)" "`subshell2`"
      ```

      Process substitution:

      ```sh
      regular <(subshell1) >(subshell2)
      ```

      Some forms of grouping:

      ```sh
      ( subshell )
      { regular; }
      ```

      Backgrounding:

      ```sh
      subshell1 &
      subshell2 &
      ```

      Anything executed by external processes:

      ```sh
      find . -exec subshell1 {} \;
      find . -print0 | xargs -0 subshell2
      sudo subshell3
      su -c subshell4
      ```

      This applies not only to setting variables, but also setting shell options and changing directories.

      ### Exceptions

      You can ignore this error if you don't care that the changes aren't reflected, because work on the value branches and shouldn't be recombined.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1115:
  remediation_points: 50000
  content:
    body: |
      ## Remove spaces between # and ! in the shebang.

      ### Problematic code:

      ```sh
      # !/bin/sh
      echo "Hello World"
      ```

      ### Correct code:

      ```sh
      #!/bin/sh
      echo "Hello World"
      ```
      ### Rationale:

      The script has spaces between the `#` and `!` in the shebang. This is not valid.

      Remove the spaces so the OS can correctly recognize the file as a script.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2178:
  remediation_points: 50000
  content:
    body: "## Variable was used as an array but is now assigned a string.\n\n### Problematic
      code:\n\n```sh\nflags[0]=\"-r\"\nflags[1]=\"--delete-after\"\n\nif [ \"$dryrun\"
      ]\nthen\n   flags=\"--dry-run\"\nfi\n\n```\n\n### Correct code:\n\n```sh\nflags[0]=\"-r\"\nflags[1]=\"--delete-after\"\n\nif
      [ \"$dryrun\" ]\nthen\n   flags=( \"--dry-run\" )\nfi\n```\n### Rationale:\n\nShellCheck
      noticed that you have used a variable as an array, but then assign it a string.
      `array=foo` is equivalent to `array[0]=foo`, and leaves the rest of the elements
      unaffected.\n\nIn the incorrect code, `\"${flags[@]}\"` would contain `--dry-run`
      `--delete-after`.\n\nTo set an array to only a single, given element, you should
      use `array=( foo )`.\n\nIn the correct code, `\"${flags[@]}\"` will contain
      `--dry-run` only. \n\nAnother possible cause is accidentally missing the `$`
      on a previous assignment: `var=(my command); var=bar` instead of `var=$(my command);
      var=bar`. If the variable is not intended to be an array, ensure that it's never
      assigned as one.\n\n### Exceptions:\n\nShellCheck can get confused by variable
      scope if the same variable name was used as an array previously, but is a string
      in the current context. You can [[ignore]] it in this case.\n\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2108:
  remediation_points: 50000
  content:
    body: |
      ## In [\[..]], use && instead of -a.

      ### Problematic code:

      ```sh
      [[ "$1" = "-v" -a -z "$2" ]]
      ```

      ### Correct code:

      ```sh
      [[ "$1" = "-v" && -z "$2" ]]
      ```

      ### Rationale:

      `-a` for logical AND is not supported in a `[[ .. ]]` expression. Use `&&` instead.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2204:
  remediation_points: 50000
  content:
    body: "## (..) is a subshell. Did you mean [ .. ], a test expression?\n\n### Problematic
      code:\n\n```sh\nif ( -d mydir )\nthen\n  echo \"It's a directory\"\nfi\n```\n\n###
      Correct code:\n\n```sh\nif [ -d mydir ]\nthen\n  echo \"It's a directory\"\nfi\n```\n###
      Rationale:\n\nTests like `-d` to see if something is a directory or `-z` to
      see if it's non-empty are actually flags to the `test` command, and only work
      as tests in that context. `[` is an alias for `test`, so you'll frequently see
      them written as `[ -d mydir ]`.\n\n`( .. )` is completely unrelated, and is
      a subshell mostly used to scope shell modifications. They should not be used
      in `if` or `while` statements in shell scripts.\n\nIf you wanted to test a condition,
      rewrite the `( .. )` to `[ .. ]`. \n\n### Exceptions:\n\nNone. \n\nThis error
      is triggered by having a unary test operator as the first command name in a
      subshell, which won't normally happen. Note that there's a similar warning [[SC2205]]
      with a higher false positive rate.\n\n### Notice\n\nOriginal content from the
      ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1108:
  remediation_points: 50000
  content:
    body: "## You need a space before and after the = .\n\n### Problematic code:\n\n```sh\n[
      \"$var\"= 2 ]\n```\n\n### Correct code:\n\n```sh\n[ \"$var\" = 2 ]\n```\n###
      Rationale:\n\nYou appear to be missing the space on the left side of the operator.
      Shell in general, and `[` in particular, is space sensitive. Operators and operands
      must be separate tokens. \n\nPlease ensure that the operator, like the `=` in
      the example, has a space both before and after it.\n\n### Exceptions:\n\nNone.
      If you're comparing values in C style reverse order like `[ -eq == $1 ]`, use
      quotes: `[ \"-eq\" == \"$1\" ]`. Also, it's pointless since `[ a = b ]` doesn't
      assign.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2064:
  remediation_points: 50000
  content:
    body: |
      ## Use single quotes, otherwise this expands now rather than when signalled.

      ### Problematic code:

      ```sh
      trap "echo \"Finished on $(date)\"" EXIT
      ```

      ### Correct code:

      ```sh
      trap 'echo "Finished on $(date)"' EXIT
      ```

      ### Rationale:

      With double quotes, all parameter and command expansions will expand when the trap is defined rather than when it's executed.

      In the example, the message will contain the date on which the trap was declared, and not the date on which the script exits.

      Using single quotes will prevent expansion at declaration time, and save it for execution time.

      ### Exceptions

      If you don't care that the trap code is expanded early because the commands/variables won't change during execution of the script, or because you want to use the current and not the future values, then you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2126:
  remediation_points: 50000
  content:
    body: |
      ## Consider using grep -c instead of grep|wc.

      ### Problematic code:

      ```sh
      grep foo | wc -l
      ```

      ### Correct code:

      ```sh
      grep -c foo
      ```

      ### Rationale:

      This is purely a stylistic issue. `grep` can count lines without piping to `wc`.

      Note that in many cases, this number is only used to see whether there are matches (i.e. `> 0`). In these cases, it's better and more efficient to use `grep -q` and check its exit status:

      ```sh
      if grep -q pattern file
      then
        echo "The file contains the pattern"
      fi
      ```

      Also note that in `foo | grep bar | wc -l`, wc will mask the exit code of grep by default (i.e. without `set -o pipefail`), and always return success. If replacing with `foo | grep -c bar`, grep will exit non-zero when the count is 0. This is convenient for conditional statements but may require handling when used with `set -e`.

      ### Exceptions

      If you e.g. want to count characters instead of lines, and you actually care about the number and not just whether it's greater than 0, you can [[ignore]] this error.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2005:
  remediation_points: 50000
  content:
    body: |
      Useless `echo`? Instead of `echo $(cmd)`, just use `cmd`
      --------------------------------------------------------

      ### Problematic code:

      ```sh
      echo "$(cat 1.txt)"
      echo `< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c6`
      ```

      ### Correct code:

      ```sh
      cat 1.txt # In bash, but faster and still sticks exactly one newline: printf '%s\n' "$(<1.txt)"
      # The original `echo` sticks a newline; we want it too.
      < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c6; echo
      ```

      ### Rationale

      The command substitution `$(foo)` yields the result of command `foo` with trailing newlines erased, and when it is passed to `echo` it generally just gives the same result as `foo`.

      ### Exceptions

      One may want to use command substitutions plus `echo` to make sure there is exactly one trailing newline. The special command substitution `$(<file)` in `bash` is also un-outline-able.

      Anyway, echo is still not that reliable (see [[SC2039#echo-flags]]) and `printf` should be used instead.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2213:
  remediation_points: 50000
  content:
    body: |
      ## getopts specified -n, but it's not handled by this 'case'.

      ### Problematic code:

      ```sh
      while getopts "vrn" n
      do
        case "$n" in
          v) echo "Verbose" ;;
          r) echo "Recursive" ;;
          *) usage;;
        esac
      done
      ```

      ### Correct code:

      ```sh
      while getopts "vrn" n
      do
        case "$n" in
          v) echo "Verbose" ;;
          r) echo "Recursive" ;;
          n) echo "Dry-run" ;;    # -n handled here
          *) usage;;
        esac
      done
      ```
      ### Rationale:

      You have a `while getopts` loop where the corresponding `case` statement fails to handle one of the flags.

      Either add a case to handle the flag, or remove it from the `getopts` option string.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2088:
  remediation_points: 50000
  content:
    body: |
      ## Tilde does not expand in quotes. Use $HOME.

      ### Problematic code:

      ```sh
      rm "~/Desktop/$filename"
      ```

      ### Correct code:

      ```sh
      rm "$HOME/Desktop/$filename"
      ```

      ### Rationale:

      Tilde does not expand to the user's home directory when it's single or double quoted. Use double quotes and `$HOME` instead.

      Alternatively, the `~/` can be left unquoted, as in `rm ~/"Desktop/$filename"`.

      ### Exceptions

      If you don't want the tilde to be expanded, you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2152:
  remediation_points: 50000
  content:
    body: |
      ## Can only return 0-255. Other data should be written to stdout.

      ### Problematic code:

      ```sh
      myfunc() {
        return "Hello $USER"
      }
      ```

      ### Correct code:

      ```sh
      myfunc() {
        echo "Hello $USER"
        return 0
      }
      ```

      ### Rationale:

      In many languages, `return` is used to return from the function with a final result.

      In bash, `return` can only be used to signal success or failure (0 = success, 1-255 = failure), more akin to `throw/raise` in other languages.

      Results should instead be written to stdout and captured:

      ```sh
      message=$(myfunc)
      echo "The function wrote: $message"
      ```

      In functions that return small integers, such as getting the cpu temperature, the value should still be written to stdout. `return` should be reserved for error conditions, such as "can't determine CPU temperature".

      ### Exceptions:

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2028:
  remediation_points: 50000
  content:
    body: |
      # echo won't expand escape sequences. Consider printf.

      ### Problematic code:

      ```sh
      echo "Name:\t$value"
      ```

      ### Correct code:

      ```sh
      printf "Name:\t%s\n" "$value"
      ```

      ### Rationale:

      Backslash escapes like `\t` and `\n` are not expanded by echo, and become literal backslash-t, backslash-n.

      `printf` does expand these sequences, and should be used instead.

      Other, non-portable methods include `echo -e '\t'` and `echo $'\t'`. ShellCheck will warn if this is used in a script with shebang `#!/bin/sh`.

      If you actually wanted a literal backslash-t, use

      ```sh
      echo "\\t"
      ```

      ### Exceptions

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2037:
  remediation_points: 50000
  content:
    body: "##  To assign the output of a command, use var=$(cmd) .\n\n### Problematic
      code:\n\n```sh\nvar=grep -c pattern file\n```\n\n### Correct code:\n\n```sh\nvar=$(grep
      -c pattern file)\n```\n### Rationale:\n\nTo assign the output of a command to
      a variable, use `$(command substitution)`. Just typing a command after the `=`
      sign does not work.\n\n### Exceptions:\n\nNone. \n\nThis warning triggers generally
      for `var=value -flag` and `var=value *glob*`. See related warning [[SC2209]]
      which matches `var=commonCommand`. \n\n### Notice\n\nOriginal content from the
      ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2046:
  remediation_points: 50000
  content:
    body: |
      # Quote this to prevent word splitting

      ### Problematic code:

          ls -l $(getfilename)

      ### Correct code:

          # getfilename outputs 1 file
          ls -l "$(getfilename)"

          # getfilename outputs multiple files, linefeed separated
          getfilename | while IFS='' read -r line
          do
            ls -l "$line"
          done

      ### Rationale:

      When command expansions are unquoted, word splitting and globbing will occur. This often manifests itself by breaking when filenames contain spaces.

      Trying to fix it by adding quotes or escapes to the data will not work. Instead, quote the command substitution itself.

      If the command substitution outputs multiple pieces of data, use a loop instead.

      ### Exceptions

      In rare cases you actually want word splitting, such as in

          gcc $(pkg-config --libs openssl) client.c

      This is because `pkg-config` outputs `-lssl -lcrypto`, which you want to break up by spaces into `-lssl` and `-lcrypto`. An alternative is to put the variables to an array and expand it:

          args=( $(pkg-config --libs openssl) )
          gcc "${args[@]}" client.c

      The power of using an array becomes evident when you want to combine, for example, the command result with user-provided arguments:

          compile () {
              args=( $(pkg-config --libs openssl) "${@}" )
              gcc "${args[@]}" client.c
          }
          compile -DDEBUG
          + gcc -lssl -lcrypto -DDEBUG client.c

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1029:
  remediation_points: 50000
  content:
    body: |
      ## In `[[..]]` you shouldn't escape `(` or `)`.

      ### Problematic code:

      ```sh
      [[ -e ~/.bashrc -a \( -x /bin/dash -o -x /bin/ash \) ]]
      ```

      ### Correct code:

      ```sh
      [[ -e ~/.bashrc -a ( -x /bin/dash -o -x /bin/ash ) ]]
      ```

      ### Rationale:

      You don't have to -- and can't -- escape `(` or `)` inside a `[[ .. ]]` expression like you do in `[ .. ]`. Just remove the escaping.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1071:
  remediation_points: 50000
  content:
    body: |
      ## ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!

      ### Problematic code:

      ```sh
      #!/usr/bin/python
      print "Hello"
      ```

      ### Rationale:

      You have specified the shebang of an unsupported language or shell dialect.

      ShellCheck only supports a limited number of Bourne-based Unix shells: bash, ksh, dash and POSIX sh.

      It does not support scripts written for other shells like Zsh, Csh, Tcsh or PowerShell, and it does not support other scripting languages like PHP, Python, JavaScript or SQL.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2198:
  remediation_points: 50000
  content:
    body: "## Arrays don't work as operands in [ ]. Use a loop (or concatenate with
      * instead of @).\n\n### Problematic code:\n\n```sh\next=png\nallowedExt=(jpg
      bmp png)\n[ \"$ext\" = \"${allowedExt[@]}\" ] && echo \"Extension is valid\"\n```\n\n###
      Correct code:\n\n```sh\next=png\nallowedExt=(jpg bmp png)\nfor value in \"${allowedExt[@]}\"\ndo\n
      \ [ \"$ext\" = \"$value\" ] && echo \"Extension is valid\"\ndone\n```\n### Rationale:\n\nArray
      expansions become a series of words in `[ .. ]`. Operators expect single words
      only.\n\nThe problematic code is equivalent to `[ \"$ext\" = jpg bmp png ]`,
      which is invalid syntax. A typical error message is `bash: [: too many arguments`
      or `dash: somefile: unexpected operator`. \n\nInstead, use a `for` loop to iterate
      over values, and apply your condition to each.\n\nAlternatively, if you want
      to concatenate all the values in the array into a single string for your test,
      use `\"$*\"` or `\"${array[*]}\"`.\n\n### Exceptions:\n\nIf you are dynamically
      building an a test expression, make your array the only thing in the test expression.
      ShellCheck will not emit a warning for: `set -- 1 -lt 2; [ \"$@\" ]`\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2203:
  remediation_points: 50000
  content:
    body: |
      ## Globs are ignored in `[[ ]]` except right of =/!=. Use a loop.

      ### Problematic code:

      ```sh
      [[ current.log -nt backup/*.log ]] && echo "This is the latest file"

      ```

      ### Correct code:

      ```sh
      newerThanAll=true
      for log in backup/*.log
      do
        [[ current.log -nt "$log" ]] || newerThanAll=false
      done
      [[ "$newerThanAll" = "true" ]] && echo "This is the latest file"
      ```

      ### Rationale:

      Globs in `[[ ]]` will not filename expand, and will be treated literally (or as patterns on the right-hand side of `=`, `==` and `!=`).

      The problematic code is equivalent to `[[ current.log -nt 'backup/*.png' ]`, and will look for a file with a literal asterisk in the name.

      Instead, you can iterate over the filenames you want with a loop, and apply your condition to each filename.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2205:
  remediation_points: 50000
  content:
    body: "## (..) is a subshell. Did you mean [ .. ], a test expression?\n\n### Problematic
      code:\n\n```sh\nif ( 1 -lt 2 )\nthen\n  echo \"1 is less than 2\"\nfi\n```\n\n###
      Correct code:\n\n```sh\nif [ 1 -lt 2 ]\nthen\n  echo \"1 is less than 2\"\nfi\n```\n###
      Rationale:\n\nTests like `-eq` to check numeric equality or `\\<` for string
      comparison only work are actually parameters to the `test` command, and only
      work as tests in that context. `[` is an alias for `test`, so you'll frequently
      see them written as `[ 1 -eq 2 ]`.\n\n`( .. )` is completely unrelated, and
      is a subshell mostly used to scope shell modifications. They should not be used
      in `if` or `while` statements in shell scripts.\n\nIf you wanted to test a condition,
      rewrite the `( .. )` to `[ .. ]`. \n\n### Exceptions:\n\nThis error is triggered
      by having a binary operator as the first parameter in a subshell, and could
      falsely trigger on e.g. `if ( grep -eq \"foo|bar\" file )`. In these cases,
      check whether the subshell is actually needed.\n\nNote that there's a similar
      looking error [[SC2204]] with a low false positive rate.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2105:
  remediation_points: 50000
  content:
    body: |
      ## `break` is only valid in loops

      ### Problematic code:

      ```sh
      case "$1" in
          -v)
             verbose=1
             break
             ;;
          -d)
             debug=1
      esac
      ```

      ### Correct code:

      ```sh
      case "$1" in
          -v)
             verbose=1
             ;;
          -d)
             debug=1
      esac
      ```
      ### Rationale:

      `break` or `continue` was found outside a loop. These statements are only valid in loops. In particular, `break` is not required in `case` statements as there is no implicit fall-through.

      To return from a function or sourced script, use `return`. To exit a script, use `exit`.

      ### Exceptions:

      It's possible to `break`/`continue` in a function without a loop. The call will then affect the loop -- if any -- that the function is invoked from. This is obviously not good coding practice.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2002:
  remediation_points: 50000
  content:
    body: "# Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.\n\n###
      Problematic code:\n\n```sh\ncat file | tr ' ' _ | nl\ncat file | while IFS=
      read -r i; do echo \"${i%?}\"; done\n```\n\n### Correct code:\n\n```sh\n< file
      tr ' ' _ | nl  \nwhile IFS= read -r i; do echo \"${i%?}\"; done < file\n```\n\n###
      Rationale:\n\n`cat` is a tool for con\"cat\"enating files. Reading a single
      file as input to a program is considered a [Useless Use Of Cat (UUOC)](http://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat).\n\nIt's
      more efficient and less roundabout to simply use redirection. This is especially
      true for programs that can benefit from seekable input, like `tail` or `tar`.\n\nMany
      tools also accept optional filenames, e.g. `grep -q foo file` instead of `cat
      file | grep -q foo`.\n\n### Exceptions\n\nPointing out UUOC is a long standing
      shell programming tradition, and removing them from a short-lived pipeline in
      a loop can speed it up by 2x. However, it's not necessarily a good use of time
      in practice, and rarely affects correctness. [[Ignore]] as you see fit.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1099:
  remediation_points: 50000
  content:
    body: |
      ## You need a space before the #.

      ### Problematic code:

      ```sh
      while sleep 1
      do# show time
        date
      done
      ```

      ### Correct code:

      ```sh
      while sleep 1
      do # show time
        date
      done
      ```

      ### Rationale:

      ShellCheck has noticed that you have a keyword immediately followed by a `#`. In order for the `#` to start a comment, it needs to come after a word boundary such as a space.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1000:
  remediation_points: 50000
  content:
    body: |
      # $ is not used specially and should therefore be escaped.

      ### Problematic code:

      ```sh
      echo "$"
      ```

      ### Correct code:

      ```sh
      echo "\$"
      ```

      ### Rationale:
      `$` is special in double quotes, but there are some cases where it's interpreted literally:

      1. Following a backslash: `echo "\$"`
      2. In a context where the shell can't make sense of it, such as at the end of the string, (`"foo$"`) or before some constructs (`"$'foo'"`).

      To avoid relying on strange and shell-specific behavior, any `$` intended to be literal should be escaped with a backslash.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2039:
  remediation_points: 50000
  content:
    body: "## In POSIX sh, *something* is undefined.\nYou have declared that your
      script works with `/bin/sh`, but you are using features that have undefined
      behavior according to the POSIX specification. \n\nIt may currently work for
      you, but it can or will fail on other OS, the same OS with different configurations,
      from different contexts (like initramfs/chroot), or in different versions of
      the same OS, including future updates to your current system.\n\nEither declare
      that your script requires a specific shell like `#!/bin/bash` or `#!/bin/dash`,
      or rewrite the script in a portable way.\n\nFor help with rewrites, the Ubuntu
      wiki has [a list of portability issues](https://wiki.ubuntu.com/DashAsBinSh)
      that broke people's `#!/bin/sh` scripts when Ubuntu switched from Bash to Dash.
      See also [Bashism](http://mywiki.wooledge.org/Bashism) on wooledge's wiki. ShellCheck
      may not warn about all these issues.\n\n### `$'c-style-escapes'`\n\nbash, ksh:\n\n```Bash\na=$'
      \\t\\n'\n```\n\nPOSIX:\n\n```sh\na=\"$(printf '%b_' ' \\t\\n')\"; a=\"${a%_}\"
      # protect trailing \\n\n```\n\nWant some good news? See http://austingroupbugs.net/view.php?id=249#c590.\n\n###
      `$\"msgid\"`\n\nBash:\n\n```Bash\necho $\"foo $(bar) baz\"\n```\n\nPOSIX:\n\n```sh\n.
      gettext.sh # GNU Gettext sh library\n# ...\nbarout=$(bar)\neval_gettext 'foo
      $barout baz' # See GNU Gettext doc for more info.\n```\n\nOr you can change
      them to normal double quotes so you go without `gettext`.\n\n### Arithmetic
      `for` loops\n\nBash:\n\n```Bash\nfor ((init; test; next)); do foo; done\n```\n\nPOSIX:\n\n```sh\n:
      $((init))\nwhile [ $((test)) -ne 0 ]; do foo; : $((next)); done\n```\n\n###
      Arithmetic exponentiation\n\nBash:\n\n```Bash\nprintf \"%s\\n\" \"$(( 2**63
      ))\"\n```\n\nPOSIX:\n\nThe POSIX standard does not allow for exponents.  However,
      you can replicate them completely built-in using a POSIX compatible function.
      \ As an example, the `pow` function from [here](http://unix.stackexchange.com/a/7925).\n\n```sh\npow
      () {\n    set \"$1\" \"$2\" 1\n    while [ \"$2\" -gt 0 ]; do\n      set \"$1\"
      $(($2-1)) $(($1*$3))\n    done\n    # %d = signed decimal, %u = unsigned decimal\n
      \   # Either should overflow to 0\n    printf \"%d\\n\" \"$3\"\n}\n```\n\nTo
      compare:\n\n```sh\n$ echo \"$(( 2**62 ))\"\n4611686018427387904\n$ pow 2 62\n4611686018427387904\n```\n\nAlternatively,
      if you don't mind using an external program, you can use `bc`.  Be aware though:
      `bash` and other programs may abide by a certain maximum integer that `bc` does
      not (for `bash` that's: 64-bit signed long int, failing back to 32-bit signed
      long int).  \n\nExample:\n\n```Bash\n# Note the overflow that gives a negative
      number\n$ echo \"$(( 2**63 ))\"\n-9223372036854775808\n\n# No such problem\n$
      echo 2^63 | bc\n9223372036854775808\n\n# 'bc' just keeps on going\n$ echo 2^1280
      | bc\n20815864389328798163850480654728171077230524494533409610638224700807\\\n21611934672059602447888346464836968484322790856201558276713249664692\\\n98162798132113546415258482590187784406915463666993231671009459188410\\\n95379622423387354295096957733925002768876520583464697770622321657076\\\n83317005651120933244966378183760369413644440628104205339687097746591\\\n6057756101739472373801429441421111406337458176\n```\n\n###
      standalone `((..))`\n\nBash:\n\n```Bash\n((a=c+d))\n((d)) && echo d is true.\n```\n\nPOSIX:\n\n```sh\n:
      $((a=c+d)) # discard the output of the arith expn with `:` command\n[ $((d))
      -ne 0 ] && echo d is true. # manually check non-zero => true\n```\n\n### `select`
      loops\n\nIt takes extra care over terminal columns to make select loop look
      like bash's, which generates a list with multiple items on one line, or like
      `ls`.\n\nIt is, however, still possible to make a naive translation for `select
      foo in bar baz; do eat; done`:\n\n```sh\nwhile\n  _i=0 _foo= foo=\n  for _name
      in bar baz; do echo \"$((_i+=1))) $_name\"; done\n  printf '$# '; read _foo\ndo\n
      \ case _foo in 1) foo=bar;; 2) foo=baz;; *) continue;; esac\n  eat\ndone\n```\n\n###
      Here-strings\n\nBash, ksh:\n\n```Bash\ngrep aaa <<< \"$g\"\n```\n\nPOSIX:\n\n```sh\n#
      not exactly the same -- <<< adds a trailing \\n if $g doesn't end with \\n\nprintf
      '%s' \"$g\" | grep aaa\n```\n\n### echo flags\n\nSee https://unix.stackexchange.com/tags/echo/info.\n\n###
      `${var/pat/replacement}`\n\nBash:\n\n```Bash\necho \"${TERM/%-256*}\"\n```\n\nPOSIX:\n\n```sh\necho
      \"$TERM\" | sed -e 's/-256.*$//g'\n# Special case for this since we are matching
      the end:\necho \"${TERM%-256*}\"\n```\n\n### `printf %q`\n\nBash:\n\n```Bash\nprintf
      '%q ' \"$@\"\n```\n\nPOSIX:\n\n```sh\n# TODO: Interpret it back to printf escapes
      for hard-to-copy chars like \\t?\n# See also: http://git.savannah.gnu.org/cgit/libtool.git/tree/gl/build-aux/funclib.sh?id=c60e054#n1029\nreuse_quote()(\n
      \ for i; do\n    __i_quote=$(printf '%s\\n' \"$i\" | sed -e \"s/'/'\\\\\\\\''/g\";
      echo x)\n    printf \"'%s'\" \"${__i_quote%x}\"\n  done\n)\nreuse_quote \"$@\"\n```\n\n##
      Exception\n\nDepends on what your expected POSIX shell providers would use.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1072:
  remediation_points: 50000
  content:
    body: |
      # Unexpected ..

      *Note: There is a [known bug](../issues/1036) in the current version when [directives](../wiki/Directive) appear within `then` clauses of `if` blocks that causes Shellcheck to report SC1072 on otherwise valid code. Avoid using directives within `then` clauses - instead place them at the top of the `if` block or another enclosing block. This is fixed on the [online version](https://www.shellcheck.net/) and the next release.*

      See [Parser Error](https://github.com/koalaman/shellcheck/wiki/Parser-Error).


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1118:
  remediation_points: 50000
  content:
    body: "## Delete whitespace after the here-doc end token.\n\n### Problematic code:\n\n\"▭\"
      below indicates an otherwise invisible space:\n\n```sh\ncat << \"eof\"\nHello\neof▭
      \  \n```\n\n### Correct code:\n\n```sh\ncat << \"eof\"\nHello\neof\n```\n###
      Rationale:\n\nThe end token of your here document has trailing whitespace. This
      is invisible to the naked eye, but shells do not accept it.\n\nRemove the trailing
      whitespace.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from
      the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2216:
  remediation_points: 50000
  content:
    body: |
      ## Piping to 'rm', a command that doesn't read stdin. Wrong command or missing xargs?

      ### Problematic code:

      ```sh
      ls | echo                      # Want to print result
      cat files | rm                 # Want to delete items from a file
      find . -type f | xargs cp dir  # Want to process 'find' output
      ```

      ### Correct code:

      ```sh
      ls
      cat files | while IFS= read -r file; do rm -- "$file"; done
      find . -type f -exec cp {} dir \;
      ```

      ### Rationale:

      You are piping to one of several commands that don't read from stdin.

      This may happen when:

      * Confusing one command for another, e.g. using `echo` where `cat` was intended.
      * Incorrectly refactoring, leaving a `|` on the previous line.
      * Missing `xargs`, because stdin should be passed as positional parameters instead (use `xargs -0` if at all possible).

      Check your logic, and rewrite the command so data is passed correctly.

      ### Exceptions:

      If you've overridden a command to return output, you can either rename it to make this obvious, or [[ignore]] this message.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1020:
  remediation_points: 50000
  content:
    body: |
      ## You need a space before the if single then "]" else "]]"

      ### Problematic code:

      ```
      if [ "$STUFF" = ""]; then
      ```

      ### Correct code:

      ```
      if [ "$STUFF" = "" ]; then
      ```

      ### Rationale:
      Bourne shells are very whitespace sensitive. Adding or removing spaces can drastically alter the meaning of a script. In these cases, ShellCheck has noticed that you're missing a space at the position indicated.

      ### Exceptions
      none.

      ### Ignore
      ```
      # shellcheck disable=SC1020
      if [ "$STUFF" = ""]; then
      ...
      ```

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2077:
  remediation_points: 50000
  content:
    body: |
      ## You need spaces around the comparison operator.

      ### Problematic code:

      ```sh
      [[ 0=1 ]]
      ```

      ### Correct code:

      ```sh
      [[ 0 = 1 ]]
      ```

      ### Rationale:

      `[[ 0 = 1 ]]` means "check if 0 and 1 are equal".

      `[[ str ]]` is short form for `[[ -n str ]]`, and means "check if `str` is non-empty". It doesn't matter if `str` happens to contain `0=1`.

      Always use spaces around the comparison operator in `[..]` and `[[..]]`, otherwise it won't be recognized as an operator.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1038:
  remediation_points: 50000
  content:
    body: |
      ## Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.

      ### Problematic code:

      ```sh
      while IFS= read -r line
      do
        printf "%q\n" "$line"
      done <<(curl -s http://example.com)
      ```

      ### Correct code:

      ```sh
      while IFS= read -r line
      do
        printf "%q\n" "$line"
      done <  <(curl -s http://example.com)
      ```

      ### Rationale:

      You are using `<<(` which is an invalid construct.

      You probably meant to redirect `<` from process substitution `<(..)` instead. To do this, a space is needed between the `<` and `<(..)`, i.e. `< <(cmd)`.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1116:
  remediation_points: 50000
  content:
    body: "## Missing $ on a $((..)) expression? (or use ( ( for arrays).\n\n### Problematic
      code:\n\n```sh\nvar=((foo+1))\n```\n\n### Correct code:\n\n```sh\nvar=$((foo+1))\n```\n\n###
      Rationale:\n\nYou appear to be missing the `$` on an assignment from an arithmetic
      expression `var=$((..))` .\n\nWithout the `$`, this is an array expression which
      is either nested (ksh) or invalid (bash). \n\n### Exceptions:\n\nIf you are
      trying to define a multidimensional Ksh array, add spaces between the `( (`
      to clarify:\n\n    var=( (1 2 3) (4 5 6) )\n\n\n### Notice\n\nOriginal content
      from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2143:
  remediation_points: 50000
  content:
    body: |
      ## Use grep -q instead of comparing output with [ -n .. ].
      ### Problematic code:

      ```sh
      if [ "$(find . | grep 'IMG[0-9]')" ]
      then
        echo "Images found"
      fi
      ```

      ### Correct code:

      ```sh
      if find . | grep -q 'IMG[0-9]'
      then
        echo "Images found"
      fi
      ```

      ### Rationale:

      The problematic code has to iterate the entire directory and read all matching lines into memory before making a decision.

      The correct code is cleaner and stops at the first matching line, avoiding both iterating the rest of the directory and reading data into memory.

      ### Exceptions

      The `pipefail` bash option may interfere with this rewrite, since the `if` will now in effect be evaluating the statuses of all commands instead of just the last one. Be careful using them together.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2036:
  remediation_points: 50000
  content:
    body: |
      ## If you wanted to assign the output of the pipeline, use a=$(b | c) .

      ### Problematic code:

      ```sh
      sum=find | wc -l
      ```

      ### Correct code:

      ```sh
      sum=$(find | wc -l)
      ```

      ### Rationale:

      The intention in this code was that `sum` would in some way get the value of the command `find | wc -l`.

      However, `|` has precedence over the `=`, so the command is a two stage pipeline consisting of `sum=find` and `wc -l`.

      `sum=find` is a plain string assignment. Since it happens by itself in an independent pipeline stage, it has no effect: it produces no output, and the variable disappears when the pipeline stage finishes. Because the assignment produces no output, `wc -l` will count 0 lines.

      To instead actually assign a variable with the output of a command, command substitution `$(..)` can be used.

      ### Exceptions:

      None. This warning is triggered whenever the first stage of a pipeline is a single assignment, which is never correct.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1017:
  remediation_points: 50000
  content:
    body: |
      ## Literal carriage return. Run script through `tr -d '\r'` .

      ### Problematic code:

      ```sh
      $ cat -v myscript
      #!/bin/sh^M
      echo "Hello World"^M
      ```

      ### Correct code:

      ```sh
      $ cat -v myscript
      #!/bin/sh
      echo "Hello World"
      ```
      ### Rationale:

      The script uses Windows/DOS style `\r\n` line terminators instead of UNIX style `\n` terminators. The additional `\r` aka `^M` aka carriage return characters will be treated literally, and results in all sorts strange bugs and messages.

      You can verify this with `cat -v yourfile` and see whether or not each line ends with a `^M`. To delete them, open the file in your editor and save the file as "Unix", "UNIX/OSX Format", `:set ff=unix` or similar if it supports it.

      If you don't know how to get your editor to save a file with Unix line terminators, you can use `tr`:

          tr -d '\r' < badscript   > goodscript

      This will read a script `badscript` with possible carriage returns, and write `goodscript` without them.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1051:
  remediation_points: 50000
  content:
    body: |
      ## Semicolons directly after 'then' are not allowed. Just remove it.

      ### Problematic code:

      ```sh
      if true; then; echo "Hi"; fi
      ```

      ### Correct code:

      ```sh
      if true; then echo "Hi"; fi
      ```
      ### Rationale:

      `then` keywords should not be followed by semicolons. It's not valid shell syntax.

      You can follow them directly with a line break or another command.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1110:
  remediation_points: 50000
  content:
    body: |
      ## This is a unicode quote. Delete and retype it (or quote to make literal).

      ### Problematic code:

      ```sh
      echo ‘hello world’
      ```

      ### Correct code:

      ```sh
      echo 'hello world'
      ```

      ### Rationale:

      Some software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. Try deleting and retyping them, and/or disable “smart quotes” in your editor or OS.

      ### Exceptions

      If you want to use typographic single quotes, you can put them in double quotes (or typographic double quotes in single quotes) to make shellcheck ignore them, e.g.,

      ```sh
      printf "Warning: ‘wakeonlan’ is not installed.\n"
      ```

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1052:
  remediation_points: 50000
  content:
    body: |
      ## Semicolons directly after 'then' are not allowed. Just remove it.

      ### Problematic code:

      ```sh
      if true; then; echo "Hi"; fi
      ```

      ### Correct code:

      ```sh
      if true; then echo "Hi"; fi
      ```
      ### Rationale:

      `then` keywords should not be followed by semicolons. It's not valid shell syntax.

      You can follow them directly with a line break or another command.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2202:
  remediation_points: 50000
  content:
    body: "## Globs don't work as operands in [ ]. Use a loop.\n\n### Problematic
      code:\n\n```sh\n[ current.log -nt backup/*.log ] && echo \"This is the latest
      file\"\n\n```\n\n### Correct code:\n\n```sh\nnewerThanAll=true\nfor log in backup/*.log\ndo\n
      \ [ current.log -nt \"$log\" ] || newerThanAll=false\ndone\n[ \"$newerThanAll\"
      = \"true\" ] && echo \"This is the latest file\"\n```\n\n### Rationale:\n\nGlobs
      in `[ ]` will expand to a sequence of words, one per matching filename. Meanwhile,
      operators work on single words.\n\nThe problematic code is equivalent to `[
      current.log -nt backup/file1.log backup/file2.log backup/file3.log ]`, which
      is invalid syntax. A typical error message is `bash: [: too many arguments`
      or `dash: somefile: unexpected operator`. \n\nInstead, use a `for` loop to iterate
      over matching filenames, and apply your condition to each.\n\n### Exceptions:\n\nIf
      you know your glob will only ever match one file, you can check this explicitly
      and use the first file:\n\n```\nset -- backup/*.log\n[ $# -eq 1 ] || { echo
      \"There are too many matches.\"; exit 1; }\n[ file.log -nt \"$1\" ] && echo
      \"This is the latest file\"\n```\n\nAlternatively, [[ignore]] this warning.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1090:
  remediation_points: 50000
  content:
    body: |
      ## Can't follow non-constant source. Use a directive to specify location.

      ### Problematic code:

      ```sh
      . "$(find_install_dir)/lib.sh"
      ```

      ### Correct code:

      ```sh
      # shellcheck source=src/lib.sh
      . "$(find_install_dir)/lib.sh"
      ```

      ### Rationale:

      ShellCheck is not able to include sourced files from paths that are determined at runtime. The file will not be read, potentially resulting in warnings about unassigned variables and similar.

      Use a [[Directive]] to point shellcheck to a fixed location it can read instead.

      ### Exceptions:

      If you don't care that ShellCheck is unable to account for the file, specify `# shellcheck source=/dev/null`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1120:
  remediation_points: 50000
  content:
    body: |
      ## No comments allowed after here-doc token. Comment the next line instead.

      ### Problematic code:

      ```sh
      cat << eof  # --- Start greeting --
      Hello
      eof         # --- End greeting ---
      ```

      ### Correct code:

      ```sh
      cat << eof  # --- Start greeting --
      Hello
      eof
                  # --- End greeting ---
      ```
      ### Rationale:

      The terminator token for a here document must be on an entirely separate line. No comments are allowed on this line.

      Place the comment somewhere else, such as on the following line.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2174:
  remediation_points: 50000
  content:
    body: |
      ## When used with -p, -m only applies to the deepest directory.

      ### Problematic code:

      ```sh
      mkdir -p -m 0755 foo/bar/baz
      ```

      ### Correct code:

      ```sh
      mkdir -p foo/bar/baz
      chmod 0755 foo/bar/baz foo/bar foo
      ```

      ### Rationale:

      When using `-m 0755`, the mode of the directory created will be set to 0755. When using `-p`, parent directories which do not exist will be created, but the mode specified by `-m` will only be used on the last directory. The parent directories will get their access mode the default way, via [umask(2)].

      [umask(2)]: http://man7.org/linux/man-pages/man2/umask.2.html

      ### Exceptions:

      ShellCheck does not warn if the path only has one component, as in `mkdir -p -m 0755 mydir`, but will not attempt to determine whether this applies for a variable as in `mkdir -p -m 0755 "$mydir"`. You can mkdir/chmod separately or [[ignore]] this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2104:
  remediation_points: 50000
  content:
    body: "## In functions, use return instead of break.\n\n### Problematic code:\n\n```sh\nfoo()
      {\n  if [[ -z $1 ]]\n  then\n    break\n  fi\n  echo \"Hello $1\"\n}\n```\n\n###
      Correct code:\n\n```sh\nfoo() {\n  if [[ -z $1 ]]\n  then\n    return 1\n  fi\n
      \ echo \"Hello $1\"\n}\n```\n### Rationale:\n\n`break` or `continue` are used
      to abort or continue a loop, and are not the right way to exit a function. Use
      `return` instead.\n\n### Exceptions:\n\nThe `break` or `continue` may be intended
      for a loop that calls the function:\n\n```\n# Rarely valid\nfoo() { break; echo
      $?; }\nwhile true; do foo; done\n```\n\nThis is undefined behavior in POSIX
      sh. Different shells do different things.\n\nWhen the function is called from
      a loop:\n\n* `ksh` keeps going and `$?` is 0.\n* `bash` version 4.4+ prints
      an error \"break: only meaningful in a \\`for', \\`while', or \\`until' loop\",
      the function keeps going, and `$?` is 0. \n* `bash` versions before 4.4, will
      return from the function, break the loop calling the function, or exit a subshell
      if there's one in between.\n* `dash`, BusyBox `ash`: like above.\n\nWhen the
      function is not called from a loop:\n\n* All `bash` versions print an error
      \"break: only meaningful in a \\`for', \\`while', or \\`until' loop\", the function
      keeps going, and `$?` is 0. \n* `ksh`, `dash` and `ash` silently keep going
      and `$?` is 0.\n\nDue to the many different implementations, many of which are
      not helpful, it's recommended to use proper flow control. A typical solution
      is making sure the function `return`s success/failure, and calling `myfunction
      || break` in the loop.\n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC2045:
  remediation_points: 50000
  content:
    body: |
      ## Iterating over ls output is fragile. Use globs.

      ### Problematic code:

          for f in $(ls *.wav)
          do
            echo "$f"
          done

      ### Correct code:

          for f in *.wav
          do
            [[ -e $f ]] || break  # handle the case of no *.wav files
            echo "$f"
          done

      Also note that in Bash, `shopt -s nullglob` will allow the loop to run 0 times instead of 1 if there are no matches. There are also [several other conditions](http://mywiki.wooledge.org/BashPitfalls#for_i_in_.24.28ls_.2A.mp3.29) to be aware of.

      ### Rationale:

      When looping over a set of files, it's always better to use globs when possible. Using command expansion causes word splitting and glob expansion, which will cause problems for certain filenames (typically first seen when trying to process a file with spaces in the name).

      The following files can or will break the first loop:

          touch 'filename with spaces.wav'
          touch 'filename with * globs.wav'
          touch 'More_Globs[2003].wav'
          touch 'files_with_fønny_chæracters_in_certain_locales.wav'


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2055:
  remediation_points: 50000
  content:
    body: |
      ## You probably wanted && here

      ### Problematic code:

      ```sh
      if [[ $1 != foo || $1 != bar ]]
      then
        echo "$1 is not foo or bar"
      fi
      ```

      ### Correct code:

      ```sh
      if [[ $1 != foo && $1 != bar ]]
      then
        echo "$1 is not foo or bar"
      fi
      ```

      ### Rationale:

      This is not a bash issue, but a simple, common logical mistake applicable to all languages.

      `[[ $1 != foo || $1 != bar ]]` is always true (when `foo != bar`):

      * If `$1 = foo` then `$1 != bar` is true, so the statement is true.
      * If `$1 = bar` then `$1 != foo` is true, so the statement is true.
      * If `$1 = cow` then `$1 != foo` is true, so the statement is true.

      `[[ $1 != foo && $1 != bar ]]` matches when `$1` is neither `foo` nor `bar`:

      * If `$1 = foo`, then `$1 != foo` is false, so the statement is false.
      * If `$1 = bar`, then `$1 != bar` is false, so the statement is false.
      * If `$1 = cow`, then both `$1 != foo` and `$1  != bar` is true, so the statement is true.

      This statement is identical to `! [[ $1 = foo || $1 = bar ]]`, which also works correctly.

      ### Exceptions

      Rare.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2027:
  remediation_points: 50000
  content:
    body: |
      ## The surrounding quotes actually unquote this. Remove or escape them.

      ### Problematic code:

      ```sh
      echo "You enter "$HOSTNAME". You can smell the wumpus." >> /etc/issue
      ```

      ### Correct code:

      ```sh
      echo "You enter $HOSTNAME. You can smell the wumpus." >> /etc/issue
      ```

      ### Rationale:

      Always quoting variables and command expansions is good practice, but blindly putting quotes left and right of them is not.

      In this case, ShellCheck has noticed that the quotes around the expansion are unquoting it, because the left quote is terminating an existing double quoted string, while the right quote starts a new one:

      ```sh
      echo "You enter "$HOSTNAME". You can smell the wumpus."
           |----------|         |---------------------------|
              Quoted   No quotes           Quoted
      ```

      If the quotes were supposed to be literal, they should be escaped. If the quotes were supposed to quote an expansion (as in the example), they should be removed because this is already a double quoted string.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2153:
  remediation_points: 50000
  content:
    body: |
      ## Possible Misspelling: MYVARIABLE may not be assigned, but MY_VARIABLE is.

      ### Problematic code:

      ```sh
      MY_VARIABLE="hello world"
      echo "$MYVARIABLE"
      ```

      ### Correct code:

      ```sh
      MY_VARIABLE="hello world"
      echo "$MY_VARIABLE"
      ```

      ### Rationale:

      ShellCheck has noticed that you reference a variable that is not assigned in the script, which has a name remarkably similar to one that is explicitly assigned. You should verify that the variable name is spelled correctly.

      Note: This error only triggers for environment variables (all uppercase variables), and only when they have names similar to something assigned in the script. If the variable is script-local, it should by convention have a lowercase name, and will in that case be caught by [SC2154] whether or not it resembles another name.

      ### Exceptions:

      If you've double checked and ensured that you did not intend to reference the specified variable, you can disable this message with a [[directive]]. The message will also not appear for guarded references like `${ENVVAR:-default}` or `${ENVVAR:?Unset error message here}`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2199:
  remediation_points: 50000
  content:
    body: "## Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit *
      instead of @).\n### Problematic code:\n\n```sh\next=png\nallowedExt=(jpg bmp
      png)\n[[ \"$ext\" = \"${allowedExt[@]}\" ]] && echo \"Extension is valid\"\n```\n\n###
      Correct code:\n\n```sh\next=png\nallowedExt=(jpg bmp png)\nfor value in \"${allowedExt[@]}\"\ndo\n
      \ [[ \"$ext\" = \"$value\" ]] && echo \"Extension is valid\"\ndone\n```\n###
      Rationale:\n\nArray expansions in `[[ .. ]]` will implicitly concatenate into
      a single string, much like in assignments. The problematic code is equivalent
      to `[ \"$ext\" = \"jpg bmp png\" ]`. \n\nInstead, use a `for` loop to iterate
      over values, and apply your condition to each.\n\nAlternatively, if you do want
      to concatenate all the values in the array into a single string for your test,
      use `\"$*\"` or `\"${array[*]}\"` to make this explicit.\n\n### Exceptions:\n\nNone.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2101:
  remediation_points: 50000
  content:
    body: |
      # Named class needs outer [], e.g. [[:digit:]\].

      ### Problematic code:

      ```sh
      gzip file[:digit:]*.txt
      ```

      ### Correct code:

      ```sh
      gzip file[[:digit:]]*.txt
      ```

      ### Rationale:

      Predefined character groups are supposed to be used inside character ranges. `[:digit:]` matches one of "digt:" just like `[abc]` matches one of "abc". `[[:digit:]]` matches a digit.

      ### Exceptions

      When passing an argument to `tr` which parses these by itself without relying on globbing, you should quote it instead, e.g. `tr -d '[:digit:]'`


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2044:
  remediation_points: 50000
  content:
    body: |
      ## For loops over find output are fragile. Use find -exec or a while read loop.

      ### Problematic code:

      ```sh
      for file in $(find mydir -mtime -7 -name '*.mp3')
      do
        let count++
        echo "Playing file no. $count"
        play "$file"
      done
      echo "Played $count files"
      ```

      This will fail for filenames containing spaces and similar, such as `My File.mp3`, and has a series of potential globbing issues depending on other filenames in the directory like (if you have `MyFile2.mp3` and `MyFile[2014].mp3`, the former file will play twice and the latter will not play at all).

      ### Correct code:

      There are many possible fixes, each with its pros and cons.

      The most general fix (that requires the least amount of thinking to apply) is having `find` output a `\0` separated list of files and consuming them in a `while read` loop:

      ```sh
      while IFS= read -r -d '' file
      do
        let count++
        echo "Playing file no. $count"
        play "$file"
      done <   <(find mydir -mtime -7 -name '*.mp3' -print0)
      echo "Played $count files"
      ```

      In usage it's very similar to the `for` loop: it gets its output from a `find` statement, it executes a shell script body, it allows updating/aggregating variables, and the variables are available when the loop ends.

      It requires Bash, and works with GNU, Busybox, OS X, FreeBSD and OpenBSD find, but not POSIX find.

      ##### If `find` is just matching globs recursively

      If you don't need `find` logic like `-mtime -7` and just use it to match globs recursively (all `*.mp3` files under a directory), you can instead use `globstar` and `nullglob` instead of `find`, and still use a `for` loop:

      ```sh
      shopt -s globstar nullglob
      for file in mydir/**/*.mp3
      do
        let count++
        echo "Playing file no. $count"
        play "$file"
      done
      echo "Played $count files"
      ```

      This is bash 4 specific.


      ##### For POSIX

      If you need POSIX compliance, this is a fair approach:

      ```sh
      find mydir ! -name "$(printf "*\n*")" -name '*.mp3' > tmp
      while IFS= read -r file
      do
        let count++
        echo "Playing file #$count"
        play "$file"
      done < tmp
      rm tmp
      echo "Played $count files"
      ```

      The only problem is for filenames containing line feeds. A `! -name "$(printf "*\n*")"` has been added to simply skip these files, just in case there are any.

      If you don't need variables to be available after the loop (here, if you don't need to print the final play count at the end), you can skip the `tmp` file and just pipe from `find` to `while`.

      ##### For simple commands with no aggregation

      If you don't need a shell script loop body or any form of variable  like if we only wanted to play the file, we can dramatically simplify while maintaining POSIX compatibility:

      ```sh
      # Simple and POSIX
      find mydir -name '*.mp3' -exec play {} \;
      ```

      This does not allow things like `let counter++` because `let` is a shell builtin, not an external command.

      ##### For shell commands with no aggregation

      If we do need a shell script body but no aggregation, you can do the above but invoking `sh` (this is still POSIX):

      ```sh
      find mydir -name '*.mp3' -exec sh -c '
          echo "Playing ${1%.mp3}"
          play "$1"
        ' sh {} \;
      ```

      This would not be possible without `sh`, because `${1%.mp3}` is a shell construct that `find` can't evaluate by itself. If we had tried to `let counter++` in this loop, we would have found that the value never changes.

      Note that using `+` instead of `\;`, and using an embedded `for file in "$@"` loop rather than `"$1"`, will not allow aggregating variables. This is because for large lists, `find` will invoke the command multiple times, each time with some chunk of the input.


      ### Rationale:

      `for var in $(find ...)`  loops rely on word splitting and will evaluate globs, which will wreck havoc with filenames containing whitespace or glob characters.

      `find -exec` `for i in glob` and `find`+`while` do not rely on word splitting, so they avoid this problem.

      ### Exceptions

      If you know about and carefully apply `IFS=$'\n'` and `set -f`, you could choose to ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1077:
  remediation_points: 50000
  content:
    body: |
      # For command expansion, the tick should slant left (` vs ´).


      ### Problematic code:

      ```sh
      echo "Your username is ´whoami´"
      ```

      ### Correct code:

      ```sh
      echo "Your username is $(whoami)" # Preferred
      echo "Your username is `whoami`"  # Deprecated, will give [SC2006]
      ```

      ### Rationale:

      In some fonts it's hard to tell ticks apart, but Bash strongly distinguishes between backticks (grave accent `` ` ``), forward ticks (acute accent `´`) and regular ticks (apostrophe `'`).

      Backticks start command expansions, while forward ticks are literal. To help spot bugs, ShellCheck parses backticks and forward ticks interchangeably.

      ### Exceptions

      If you want to write out literal forward ticks, such as fancyful ascii quotation marks:

      ```sh
      echo "``Proprietary software is an injustice.´´  - Richard Stallman"
      ```

      use single quotes instead:

      ```sh
      echo '``Proprietary software is an injustice.´´  - Richard Stallman'
      ```

      To nest forward ticks in command expansion, use `$(..)` instead of `` `..` ``.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2183:
  remediation_points: 50000
  content:
    body: |
      ## This format string has 2 variables, but is passed 1 arguments.

      ### Problematic code:

      ```sh
      printf "Hello %s, welcome to %s.\n" "$USER"
      ```

      ### Correct code:

      ```sh
      printf "Hello %s, welcome to %s.\n" "$USER" "$HOSTNAME"
      ```
      ### Rationale:

      ShellCheck has noticed that you're using a `printf` format string with more `%s` variables than arguments to fill them.

      In the problematic example case, the last `%s` will just become an empty string every time.

      Either remove the unused variables from the format string, or add enough arguments to fill them.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1044:
  remediation_points: 50000
  content:
    body: "**COULDN'T FIND THE END OF THE HERE DOC.** The starting Here tag must match
      the closing Here tag. \n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC2211:
  remediation_points: 50000
  content:
    body: "## This is a glob used as a command name. Was it supposed to be in ${..},
      array, or is it missing quoting?\n\n### Problematic code:\n\n```sh\nfor f in
      $(*.png); do echo \"$f\"; done   # Trying to loop over a glob\narray=$(*.txt)
      \                         # Trying to assign an array\necho \"$(array[1])\"
      \                     # Trying to expand an array\n```\n\n### Correct code:\n\n```sh\nfor
      f in *.png; do echo \"$f\"; done\narray=(*.txt)\necho \"${array[1]}\"\n```\n\n###
      Rationale:\n\nYou are using a glob as a command name. This is usually a mistake
      caused by one of the following:\n\n* Trying to use `` `*foo*` `` or `$(*foo*)`
      to expand a glob. \n* Using `var=$(*.txt)` instead of `var=(*.txt)` to assign
      an array.\n* Using `$(..)` instead of `${..}` when expanding an array element.\n*
      Running a program with a name or directory that contains glob characters without
      escaping them.\n\nLook up and double check the syntax of what you're trying
      to do.\n\n### Exceptions:\n\nNone. If you want to specify a command name via
      glob, e.g. to not hard code version in `./myprogram-*/foo`, expand to array
      or parameters first to allow handling the cases of 0 or 2+ matches. \n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1068:
  remediation_points: 50000
  content:
    body: |
      # Don't put spaces around the = in assignments.

      ### Problematic code:

      ```sh
      foo = 42
      ```

      ### Correct code:

      ```sh
      foo=42
      ```

      ### Rationale:

      Shells are space sensitive. `foo=42` means to assign `42` to the variable `foo`. `foo = 42` means to run a command named `foo`, and pass `=` as `$1` and `42` as `$2`.

      ### Exceptions

      If you actually wanted to run a command named foo and provide `=` as the first argument, simply quote it to make ShellCheck be quiet: `foo "=" 42`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2074:
  remediation_points: 50000
  content:
    body: |
      ## Can't use `=~` in `[ ]`. Use `[[..]]` instead.

      ### Problematic code:

      ```sh
      [ "$input" =~ DOC[0-9]*\.txt ] && echo "match"
      ```

      ### Correct code:

      ```sh
      [[ "$input" =~ DOC[0-9]*\.txt ]] && echo "match"
      ```
      ### Rationale:

      `=~` only works in `[[ .. ]]` tests. It does not work with `test` or `[` in any shell.

      If you're targeting POSIX `sh`, rewrite in terms of `case` or `grep` instead.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1066:
  remediation_points: 50000
  content:
    body: |
      ## Don't use $ on the left side of assignments.

      ### Problematic code:

      ```sh
      $greeting="Hello World"
      ```

      ### Correct code:

      ```sh
      greeting="Hello World"
      ```

      Alternatively, if the goal was to assign to a variable whose name is in another variable (indirection), use `declare`:

      ```sh
      name=foo
      declare "$name=hello world"
      echo "$foo"
      ```

      ### Rationale:

      Unlike Perl or PHP, `$` is not used when assigning to a variable.

      ### Exceptions

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1104:
  remediation_points: 50000
  content:
    body: "## Use #!, not just !, for the shebang.\n\n### Problematic code:\n\n```sh\n!/bin/sh\necho
      \"Hello\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello\"\n```\n\n###
      Rationale:\n\nYou appear to be specifying an interpreter in a shebang, but it's
      missing the hash part. The shebang must always start with `#!`. \n\nEven the
      name \"shebang\" itself comes from \"hash\" (`#`) + \"bang\" (`!`). \n\n###
      Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2184:
  remediation_points: 50000
  content:
    body: |
      ## Quote arguments to unset so they're not glob expanded.

      ### Problematic code:

      ```sh
      unset foo[index]
      ```

      ### Correct code:

      ```sh
      unset 'foo[index]'
      ```
      ### Rationale:

      Arguments to `unset` are subject to regular glob expansion. This is especially relevant when unsetting indices in arrays, where `[..]` is considered a glob character group.

      In the problematic code, having a file called `food` in the current directory will result in `unset foo[index]` expanding to `unset food`, which will silently succeed without unsetting the element.

      Quoting so that the `[..]` is passed literally to `unset` solves the issue.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2008:
  remediation_points: 50000
  content:
    body: |
      ## echo doesn't read from stdin, are you sure you should be piping to it?

      ### Problematic code:

      ```sh
      find . | echo
      ```

      ### Correct code:

      ```sh
      find .
      ```

      ### Rationale:

      You are piping command output to `echo`, but `echo` ignores all piped input.

      In particular, `echo` is not responsible for putting output on screen. Commands already output data, and with no further actions that will end up on screen.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1037:
  remediation_points: 50000
  content:
    body: |
      ## Braces are required for positionals over 9, e.g. ${10}.

      ### Problematic code:

      ```sh
      echo "Ninth parameter: $9"
      echo "Tenth parameter: $10"
      ```

      ### Correct code:

      ```sh
      echo "Ninth parameter: $9"
      echo "Tenth parameter: ${10}"
      ```

      ### Rationale:

      For legacy reasons, `$10` is interpreted as the variable `$1` followed by the literal string `0`.

      Curly braces are needed to tell the shell that both digits are part of the parameter expansion.

      Please note that accessing any positional parameters beyond `$9` using `${num}` is non-POSIX.

      ### Exceptions

      If you wanted the trailing digits to be literal, `${1}0` will make this clear to both humans and shellcheck.

      In `dash`, `$10` is ([wrongly](https://gnu.org/s/autoconf/manual/html_node/Shell-Substitutions.html)) interpreted as `${10}`, so some 'reversed' care should also be taken:

      ```sh
      bash -c 'set a b c d e f g h i j; echo $10 ${1}0' # POSIX: a0 a0
      dash -c 'set a b c d e f g h i j; echo $10 ${1}0' # WRONG: j a0
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2122:
  remediation_points: 50000
  content:
    body: |
      ## >= is not a valid operator. Use '! a < b' instead.

      ### Problematic code:

      ```sh
      [[ a &lt;= b ]]
      ```

      ### Correct code:

      ```sh
      [[ ! a > b ]]
      ```

      ### Rationale:

      The operators `<=` and `>=` are not supported by Bourne shells. Instead of "less than or equal", rewrite as "not greater than".

      ### Exceptions

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1083:
  remediation_points: 50000
  content:
    body: |
      ## This `{`/`}` is literal. Check expression (missing `;/\n?`) or quote it.

      ### Problematic code:

      ```sh
      rmf() { rm -f "$@" }
      ```

      or

      ```sh
      eval echo \${foo}
      ```

      ### Correct code:

      ```sh
      rmf() { rm -f "$@"; }
      ```

      and

      ```sh
      eval "echo \${foo}"
      ```

      ### Rationale:

      Curly brackets are normally used as syntax in parameter expansion, command grouping and brace expansion.

      However, if they don't appear alone at the start of an expression or as part of a parameter or brace expansion, the shell silently treats them as literals. This frequently indicates a bug, so ShellCheck warns about it.

      In the example function, the `}` is literal because it's not at the start of an expression. We fix it by adding a `;` before it.

      In the example eval, the code works fine. However, we can quiet the warning and follow good practice by adding quotes around the literal data.

      ShellCheck does not warn about `{}`, since this is frequently used with `find` and rarely indicates a bug.

      ### Exceptions

      This error is harmless when the curly brackets are supposed to be literal, in e.g. `awk {'print $1'}`. However, it's cleaner and less error prone to simply include them inside the quotes: `awk '{print $1}'`.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2103:
  remediation_points: 50000
  content:
    body: |
      # Use a ( subshell ) to avoid having to cd back.

      ### Problematic code:

      ```sh
      for dir in */
      do
        cd "$dir"
        convert index.png index.jpg
        cd ..
      done
      ```


      ### Correct code:

      ```sh
      for dir in */
      do
        (
        cd "$dir" || exit
        convert index.png index.jpg
        )
      done
      ```

      or

      ```sh
      for dir in */
      do
        cd "$dir" || exit
        convert index.png index.jpg
        cd ..
      done
      ```

      ### Rationale:

      When doing `cd dir; somestuff; cd ..`, `cd dir` can fail when permissions are lacking, if the dir was deleted, or if `dir` is actually a file.

      In this case, `somestuff` will run in the wrong directory and `cd ..` will take you to an even more wrong directory. In a loop, this will likely cause the next `cd` to fail as well, propagating this error and running these commands far away from the intended directories.

      Check `cd`s exit status and/or use subshells to limit the effects of `cd`.

      ### Exceptions

      If you set variables you can't use a subshell. In that case, you should definitely check the exit status of `cd`, which will also silence this suggestion.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2053:
  remediation_points: 50000
  content:
    body: |
      ## Quote the rhs of = in [[ ]] to prevent glob matching.

      ### Problematic code:

      ```sh
      [[ $a = $b ]]
      ```

      ### Correct code:

      ```sh
      [[ $a = "$b" ]]
      ```
      ### Rationale:

      When the right-hand side of `=`, `==` or `!=` is unquoted in `[[ .. ]]`, it will be treated like a glob.

      This has some unexpected consequences like `[[ $var = $var ]]` being false (for `var='[a]'`), or `[[ $foo = $bar ]]` giving a different result from `[[ $bar = $foo ]]`.

      The most common intention is to compare one variable to another as strings, in which case the right-hand side must be quoted.

      ### Exceptions:

      If you explicitly want to match against a pattern, you can [[ignore]] this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2081:
  remediation_points: 50000
  content:
    body: "## `[ .. ]` can't match globs. Use `[[ .. ]]` or grep.\n\n### Problematic
      code:\n\n```sh\nif [ $var == *[^0-9]* ]\nthen\n  echo \"$var is not numeric\"\nfi
      \n```\n\n### Correct code:\n\n```sh\nif [[ $var == *[^0-9]* ]]\nthen\n  echo
      \"$var is not numeric\"\nfi \n```\n### Rationale:\n\n`[ .. ]` aka `test` can
      not match against globs. \n\nIn bash/ksh, you can instead use `[[ .. ]]` which
      supports this behavior.\n\nIn sh, you can rewrite to use `grep`. \n\n### Exceptions:\n\nNone.
      If you are not trying to match a glob, quote the argument (e.g. `[ $var == '*'
      ]` to match literal asterisk. \n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC2040:
  remediation_points: 50000
  content:
    body: |
      ## #!/bin/sh was specified, so ____ is not supported, even when sh is actually bash.

      The shebang indicates that the script works with `/bin/sh`, but you are using non-standard features that may not work with `/bin/sh`, **even if /bin/sh is actually bash**. Bash behaves differently when invoked as `sh`, and disabling support for the highlighted feature is one part of that.

      Specify `#!/usr/bin/env bash` to ensure that bash (or your shell of choice) will be used, or rewrite the script to be more portable.

      The Ubuntu wiki has [a list of portability issues](https://wiki.ubuntu.com/DashAsBinSh) and suggestions on how to rewrite them.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2187:
  remediation_points: 50000
  content:
    body: "## Ash scripts will be checked as Dash. Add '# shellcheck shell=dash' to
      silence.\n\n### Problematic code:\n\n```sh\n#!/bin/ash\necho \"Hello World\"\n```\n\n###
      Correct code:\n\n```sh\n#!/bin/ash\n# shellcheck shell=dash\necho \"Hello World\"\n```\n###
      Rationale:\n\nShellCheck has no first class support for `ash`, but it does support
      its Debian fork `dash` and defaults to this whenever `ash` is specified.\n\nUnfortunately,
      while the two are similar, they are not completely compatible. For example,
      `ash` supports `echo -e` but `dash` does not, so ShellCheck will incorrectly
      warn about it.\n\nYou can use a [[directive]] to let ShellCheck know you're
      aware of this problem.\n\n### Exceptions:\n\nNone. \n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1028:
  remediation_points: 50000
  content:
    body: |
      ## In [..] you have to escape \\( \\) or preferably combine [..] expressions.

      ### Problematic code:

      ```sh
      [ -e ~/.bashrc -a ( -x /bin/dash -o -x /bin/ash ) ]
      ```

      ### Correct code:

      In POSIX:
      ```sh
      [ -e ~/.bashrc ] &&  { [ -x /bin/dash ] || [ -x /bin/ash ]; }
      ```

      Obsolete XSI syntax:
      ```sh
      [ -e ~/.bashrc -a \( -x /bin/dash -o -x /bin/ash \) ]
      ```

      ### Rationale:

      `[` is implemented as a regular command, so `(` is not special.

      The preferred way is not to group inside `[ .. ]` and instead compose multiple `[ .. ]` statments using the shell's `&&`, `||` and `{ ..; }` syntax, since this is well defined by POSIX.

      Some shells, such as Bash, support grouping with `\( .. \)`, but this is an obsolete XSI-only extension.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2007:
  remediation_points: 50000
  content:
    body: |
      # Use $((..)) instead of deprecated $[..]

      ### Problematic code

      ```sh
      n=1
      n=$[n+1]
      ```

      ### Correct code

      ```sh
      n=1
      n=$((n+1))
      ```

      ### Rationale

      The `$[..]` syntax was deprecated in Bash 2.0 and replaced with the standard `$((..))` syntax from Korn shell

      ### Exceptions

      None.

      ### See also

      - http://unix.stackexchange.com/questions/209833/what-does-a-dollar-sign-followed-by-a-square-bracket-mean-in-bash

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2050:
  remediation_points: 50000
  content:
    body: |
      ## This expression is constant. Did you forget the `$` on a variable?
      ### Problematic code:

      ```sh
      if [ myvar = "test" ]
      then
        echo "Test mode"
      fi
      ```

      ### Correct code:

      ```sh
      if [ "$myvar" = "test" ]
      then
        echo "Test mode"
      fi
      ```
      ### Rationale:

      ShellCheck has found a `[ .. ]` or `[[ .. ]]` comparison that only involves literal strings. The intention was probably to check a variable or command output instead.

      This is usually due to missing `$` or bad quoting:

          if [[ "myvar" = "test" ]]             # always false because myvar is a literal string
          if [[ "$myvar" = "test" ]]            # correctly compares a variable

          if [ 'grep -c foo bar' -ge 10 ]       # always false because grep doesn't run
          if [ "$(grep -c foo bar)" -ge 10 ]    # correctly checks grep output

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1011:
  remediation_points: 50000
  content:
    body: |
      ## This apostrophe terminated the single quoted string!

      ### Problematic code:

      ```sh
      echo 'Nothing so needs reforming as other people's habits.'
      ```

      ### Correct code:

      ```sh
      echo 'Nothing so needs reforming as other people'\''s habits.'
      ```
      or
      ```sh
      echo "Nothing so needs reforming as other people's habits."
      ```
      ### Rationale:

      When writing a string in single quotes, you have to make sure that any apostrophes in the text don't accidentally terminate the single quoted string prematurely.

      Escape them properly (see the correct code) or switch quotes to avoid the problem.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2142:
  remediation_points: 50000
  content:
    body: |
      ## Aliases can't use positional parameters. Use a function.

      ### Problematic code:

      ```sh
      alias archive='mv "$@" /backup'
      ```

      ### Correct code:

      ```sh
      archive() { mv "$@" /backup; }

      ```

      ### Rationale:

      Aliases just substitute the start of a command with something else. They therefore can't use positional parameters, such as `$1`. Rewrite your alias as a function.

      ### Exceptions

      If your alias ends up quoting the value, e.g. `alias cut_first="awk '{print \$1}'"`, you can technically [[ignore]] this error. However, you should consider turning this alias into a more readable function instead: `cut_first() { awk '{print $1}' "$@"; }`

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2019:
  remediation_points: 50000
  content:
    body: |
      ## Use '[:upper:]' to support accents and foreign alphabets.

      See the equivalent warning for lowercase matching: [[SC2018]]

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2180:
  remediation_points: 50000
  content:
    body: |
      ## Bash does not support multidimensional arrays. Use 1D or associative arrays.

      ### Problematic code:

      ```sh
      foo[1][2]=bar
      echo "${foo[1][2]}"
      ```

      ### Correct code:

      In bash4, consider using associative arrays:
      ```sh
      declare -A foo
      foo[1,2]=bar
      echo "${foo[1,2]}"
      ```

      Otherwise, do your own index arithmetic:
      ```sh
      size=10
      foo[1*size+2]=bar
      echo "${foo[1*size+2]}"
      ```

      ### Rationale:

      Bash does not support multidimensional arrays. Rewrite it to use 1D arrays. Associative arrays map arbitrary strings to values, and are therefore useful since you can construct keys like `"1,2,3"` or `"val1;val2;val3"` to index them.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2056:
  remediation_points: 50000
  content:
    body: |
      ## You probably wanted && here

      ### Problematic code:

      ```sh
      if  (( $1 != 0 || $1 != 3 ))
      then
        echo "$1 is not 0 or 3"
      fi
      ```

      ### Correct code:

      ```sh
      if  (( $1 != 0 && $1 != 3 ))
      then
        echo "$1 is not 0 or 3"
      fi
      ```

      ### Rationale:

      This is not a bash issue, but a simple, common logical mistake applicable to all languages.

      `(( $1 != 0 || $1 != 3 ))` is always true:

      * If `$1 = 0` then `$1 != 3` is true, so the statement is true.
      * If `$1 = 3` then `$1 != 0` is true, so the statement is true.
      * If `$1 = 42` then `$1 != 0` is true, so the statement is true.

      `(( $1 != 0 && $1 != 3 ))` is true only when `$1` is not `0` and not `3`:

      * If `$1 = 0`, then `$1 != 3` is false, so the statement is false.
      * If `$1 = 3`, then `$1 != 0` is false, so the statement is false.
      * If `$1 = 42`, then both `$1 != 0` and `$1  != 3` is true, so the statement is true.

      This statement is identical to `! (( $1 == 0 || $1 == 3 ))`, which also works correctly.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2221:
  remediation_points: 50000
  content:
    body: "## This pattern always overrides a later one.\n\n### Problematic code:\n\n```sh\ncase
      \"$1\" in\n  -?) echo \"Usage: $0 [-n]\";;\n  -n) echo \"Hello World\";;\n   *)
      exit 1;;\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"$1\" in\n  -\\?) echo
      \"Usage: $0 [-n]\";;\n  -n) echo \"Hello World\";;\n   *) exit 1;;\nesac\n```\n###
      Rationale:\n\nYou have specified multiple patterns in a `case` statement, where
      one will always override the other. The pattern being overridden is indicated
      with a [[SC2222]] warning.\n\nIn the example, `-?` actually matches a dash followed
      by any character, such as `-n`. This means that the later `-n` branch will never
      trigger. In this case, the correct solution is to escape the `-\\?` so that
      it doesn't match `-n`. \n\nAnother common reason for this is accidentally duplicating
      a branch. In this case, fix or delete the duplicate branch.\n\n### Exceptions:\n\nNone.
      One could argue that having `-*|--*) echo \"Invalid flag\";` is a readability
      issue, even though the second pattern follows from the first. In this case,
      you can either rearrange the pattern from most to least specific, i.e. `--*|-*)`
      or ignore the error.\n\nWhen ignoring this error, remember that ShellCheck directives
      have to go in front of the `case` statement, and not in front of the branch:\n\n
      \   # shellcheck disable=SC2221,SC2222\n    case \"$1\" in\n      -n) ...;;\n
      \     # no directive here\n      -*|--*) echo \"Unknown flag\" ;;\n    esac\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2063:
  remediation_points: 50000
  content:
    body: |
      # Grep uses regex, but this looks like a glob.

      ### Problematic code:

      ```sh
      grep '*foo*'
      ```

      ### Correct code:

      ```sh
      grep 'foo'   # or more explicitly,  grep '.*foo.*'
      ```

      ### Rationale:

      In globs, `*` matches any number of any character.

      In regex, `*` matches any number of the preceding character.

      `grep` uses regex, not globs, so this means that `grep '*foo'` is nonsensical because there's no preceding character for `*`.

      If the intention was to match "any number of characters followed by foo", use `'.*foo'`. Also note that since grep matches substrings, this will match "fishfood". Use anchors to prevent this, e.g. `foo$`.

      This also means that `f*` will match "hello", because `f*` matches 0 (or more) "f"s and there are indeed 0 "f" characters in "hello". Again, use `grep 'f'` to find strings containing "f", or `grep '^f'` to find strings starting with "f".


      ### Exceptions

      If you're aware of the differences between globs and regex, you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2206:
  remediation_points: 50000
  content:
    body: |
      ## Quote to prevent word splitting, or split robustly with mapfile or read -a.

      ### Problematic code:

      ```sh
      array=( $var )
      ```

      ### Correct code:

      If the variable should be a single element:

      ```sh
      array=( "$var" )
      ```

      If it's multiple lines, each of which should be an element:

      ```sh
      # For bash
      mapfile -t array <<< "$var"

      # For ksh
      printf '%s\n' "$var" | while IFS="" read -r line; do array+=("$line"); done
      ```

      If it's a line with multiple words (separated by spaces, other delimiters can be chosen with IFS), each of which should be an element:

      ```sh
      # For bash
      IFS=" " read -r -a array <<< "$var"

      # For ksh
      IFS=" " read -r -A array <<< "$var"
      ```

      ### Rationale:

      You are expanding a variable unquoted in an array. This will invoke the shell's sloppy word splitting and glob expansion.

      Instead, prefer explicitly splitting (or not splitting):

      * If the variable should become a single array element, quote it.
      * If you want to split into lines or words, use `mapfile`, `read -ra` and/or `while` loops as appropriate.

      This prevents the shell from doing unwanted splitting and glob expansion, and therefore avoiding problems with data containing spaces or special characters.

      ### Exceptions:

      If you have already taken care (through setting IFS and `set -f`) to have word splitting work the way you intend, you can ignore this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2014:
  remediation_points: 50000
  content:
    body: |
      ## This will expand once before find runs, not per file found.

      ### Problematic code:

      ```sh
      find . -name '*.tar' -exec tar xf {} -C "$(dirname {})" \;
      ```

      ### Correct code:

      ```sh
      find . -name '*.tar' -exec sh -c 'tar xf "$1" -C "$(dirname "$1")"' _ {} \;
      ```

      ### Rationale:

      Bash evaluates any command substitutions before the command they feature in is executed. In this case, the command is `find`. This means that `$(dirname {})` will run **before** `find` runs, and not **while** `find` runs.

      To run shell code for each file, we can write a tiny script and inline it with `sh -c`. We add `_` as a dummy argument that becomes `$0`, and a filename argument that becomes `$1` in the inlined script:

      ```sh
      $ sh -c 'echo "$1 is in $(dirname "$1")"' _ "mydir/myfile"
      mydir/myfile is in mydir
      ```

      This command can be executed by `find -exec`, with `{}` as the filename argument. It executes shell which interprets the inlined script once for each file. Note that the inlined script is single quoted, again to ensure that the expansion does not happen prematurely .

      ### Exceptions:

      If you don't care (or if you prefer) that it's only expanded once, like when dynamically selecting the executable to be used by all invocations, you can ignore this message.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2095:
  remediation_points: 50000
  content:
    body: "## Add < /dev/null to prevent ssh from swallowing stdin.\n\nThe same error
      applies to multiple commands, like `ffmpeg` and `mplayer`.\n\n### Problematic
      code:\n\n```sh\nwhile read -r host\ndo\n  ssh \"$host\" \"uptime\"\ndone < hosts.txt\n```\n\n###
      Correct code:\n\n```sh\nwhile read -r host\ndo\n  ssh \"$host\" \"uptime\" <
      /dev/null\ndone < hosts.txt\n```\n### Rationale:\n\nCommands that process stdin
      will compete with the `read` statement for input. This is especially tricky
      for commands you wouldn't expect reads from stdin, like `ssh .. uptime`, `ffmpeg`
      and `mplayer`.\n\nThe most common symptom of this is a `while read` loop only
      running once, even though the input contains many lines. This is because the
      rest of the lines are swallowed by the offending command.\n\nTo refuse such
      commands input, redirect their stdin with `< /dev/null`.\n\nYou can also use
      command specific options like `ssh -n` and `mplayer -noconsolecontrols`. \n\n###
      Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2024:
  remediation_points: 50000
  content:
    body: "## `sudo` doesn't affect redirects. Use `..| sudo tee file`\r\n\r\n###
      Problematic code:\r\n\r\n```\r\nsudo echo 'export FOO=bar' >> /etc/profile\r\n```\r\n\r\n###
      Correct code:\r\n\r\n```\r\necho 'export FOO=bar' | sudo tee -a /etc/profile
      > /dev/null\r\n```\r\n\r\n### Rationale:\r\n\r\nRedirections are performed by
      the current shell before `sudo` is started. This means that it will use the
      current shell's user and permissions to open and write to the file.\r\n\r\n`tee`
      is a simple command that opens and writes to files without help from the shell,
      which means that it will use the permissions that `sudo` grants it.\r\n\r\nThere
      is nothing special about `tee`. It's just the simplest command that can both
      truncate and append to files without help from the shell. Here are equivalent
      alternatives:\r\n\r\nTruncating:\r\n\r\n```\r\necho 'data' | sudo dd of=file\r\necho
      'data' | sudo sed 'w file'\r\n```\r\n\r\nAppending: \r\n\r\n```\r\necho 'data'
      | sudo awk '{ print $0 >> \"file\" }'\r\necho 'data' | sudo sh -c 'cat >> file'\r\n```\r\n\r\n###
      Exceptions\r\n\r\nIf you want to run a command as root but redirect as the normal
      user, you can ignore this message.\r\n\n\n### Notice\n\nOriginal content from
      the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2128:
  remediation_points: 50000
  content:
    body: |
      ## Expanding an array without an index only gives the first element.

      ### Problematic code:

      ```sh
      myarray=(foo bar)
      for f in $myarray
      do
        cat "$f"
      done
      ```

      ### Correct code:

      ```sh
      myarray=(foo bar)
      for f in "${myarray[@]}"
      do
        cat "$f"
      done
      ```

      ### Rationale:

      When referencing arrays, `$myarray` is equivalent to `${myarray[0]}` -- it results in only the first of multiple elements.

      To get all elements as separate parameters, use the index `@` (and make sure to double quote). In the example, `echo "${myarray[@]}"` is equivalent to `echo "foo" "bar"`.

      To get all elements as a single parameter, concatenated by the first character in `IFS`, use the index `*`. In the example, `echo "${myarray[*]}"` is equivalent to `echo "foo bar"`.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1098:
  remediation_points: 50000
  content:
    body: |
      ## Quote/escape special characters when using eval, e.g. eval "a=(b)".

      ### Problematic code:

      ```sh
      eval $var=(a b)
      ```

      ### Correct code:

      ```sh
      eval "$var=(a b)"
      ```

      ### Rationale:

      Shells differ widely in how they handle unescaped parentheses in `eval` expressions.

      * `eval foo=bar` is allowed by dash, bash and ksh.
      * `eval foo=(bar)` is allowed by bash and ksh, but not dash.
      * `eval $var=(bar)` is allowed by ksh, but not bash or dash.
      * `eval foo() ( echo bar; )` is not allowed by any shell.

      Since the expression is evaluated as shell script code anyways, it should be passed in as a literal string without relying on special case parsing rules in the target shell. Quote/escape the characters accordingly.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2090:
  remediation_points: 50000
  content:
    body: |
      # Quotes/backslashes in this variable will not be respected.

      See companion warning, [[SC2089]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2067:
  remediation_points: 50000
  content:
    body: |
      ## Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument.

      ### Problematic code:

      ```sh
      find . -type f -exec shellcheck {} | wc -l \;
      find . -exec echo {} ;
      ```

      ### Correct code:

      ```sh
      find . -type f -exec sh -c 'shellcheck "$1" | wc -l' -- {} \;
      find . -exec echo {} \;
      ```

      ### Rationale:

      `find -exec` is still subject to all normal shell rules, so all shell features like `|`, `||`, `&` and `&&` will apply to the `find` command itself, and not to the command you are trying to construct with `-exec`.

      `find . -exec foo {} && bar {} \;` means run the command `find . -exec foo {}`, and if find is successful, run the command `bar "{}" ";"`.

      To instead go through each file and run `foo file && bar file` on it, invoke a shell that can interpret `&&`:

      ```sh
      find . -exec sh 'foo "$1" && bar "$1"' -- {} \;
      ```

      You can also use find `-a` instead of shell `&&`:

      ```sh
      find . -exec foo {} \; -a -exec bar {} \;
      ```

      This will have the same effect (`-a` is also the default when two commands are specified, and can therefore be omitted).

      ### Exceptions

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2162:
  remediation_points: 50000
  content:
    body: |
      ## read without -r mangle backslashes

      ### Problematic code:

      ```sh
      echo "Enter name:"
      read name
      ```

      ### Correct code:

      ```sh
      echo "Enter name:"
      read -r name
      ```

      ### Rationale:

      By default, `read` will interpret backslashes before spaces and line feeds, and otherwise strip them. This is rarely expected or desired.

      Normally you just want to read data, which is what `read -r` does. You should always use `-r` unless you have a good reason not to.

      Note that `read -r` will still strip leading and trailing spaces. `IFS="" read -r` prevents this.

      ### Exceptions:

      If you want backslashes to affect field splitting and line terminators instead of being read, you can disable this message with a [[directive]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2033:
  remediation_points: 50000
  content:
    body: |
      # Shell functions can't be passed to external commands.

      ### Problematic code:

      ```sh
      foo() { bar --baz "$@"; frob --baz "$@"; };
      find . -exec foo {} +
      ```

      ### Correct code:

      ```sh
      find . -exec sh -c 'bar --baz "$@"; frob --baz "$@";' -- {} +
      ```

      ### Rationale:

      Shell functions are only known to the shell. External commands like `find`, `xargs`, `su` and `sudo` do not recognize shell functions.

      Instead, the function contents can be executed in a shell, either through `sh -c` or by creating a separate shell script as an executable file.

      ### Exceptions

      If you're intentionally passing a word that happens to have the same name as a declared function, you can quote it to make shellcheck ignore it, e.g.

      ```sh
      nobody() {
        sudo -u "nobody" "$@"
      }

      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2094:
  remediation_points: 50000
  content:
    body: |
      # SC2094 Make sure not to read and write the same file in the same pipeline.

      ### Problematic code:

      ```sh
      grep foo file.txt | sed -e 's/foo/bar/g' > file.txt
      ```

      ### Correct code:

      ```sh
      grep foo file.txt  | sed -e 's/foo/bar/g' > tmpfile && mv tmpfile file.txt
      ```

      ### Rationale:

      Each step in a pipeline runs in parallel.

      In this case, `grep foo file.txt` will immediately try to read `file.txt` while `sed .. > file.txt` will immediately try to truncate it.

      This is a race condition, and results in the file being partially or (far more likely) entirely truncated.

      ### Exceptions

      You can ignore this error if:

      * The file is a device or named pipe. These files don't truncate in the same way.
      * The command mentions the filename but doesn't read/write it, such as `echo log.txt > log.txt`.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2091:
  remediation_points: 50000
  content:
    body: |
      ## Remove surrounding $() to avoid executing output.

      ### Problematic code:

      ```sh
      if $(which epstopdf)
      then
        echo "Found epstopdf"
      fi
      ```

      ### Correct code:

      ```sh
      if which epstopdf
      then
        echo "Found epstopdf"
      fi
      ```

      ### Rationale:

      ShellCheck has detected that you have a command that just consists of a command substitution.

      This is typically done in order to try to get the shell to execute a command, because `$(..)` does indeed execute commands. However, it's also replaced by the output of that command.

      When you run `echo "The date is $(date +%F)"`, bash evalutes the `$(..)`. The command then becomes `echo "The date is 2015-04-29"`, which writes out the string `The date is 2015-04-29`

      The problem is when you use `$(date +%F)` alone as a command. Bash evaluates the `$(..)`, and the command then becomes `2015-04-29`. There is no command called `2015-04-29`, so you get `bash: 2015-04-29: command not found`.

      Sometimes this results in this confounding `command not found` messages. Other times you get even stranger issues, like the example problematic code which always evaluates to false.

      The solution is simply to remove the surrounding `$()`. This will execute the command instead of the command's output.

      ### Exceptions:

      If you really want to execute the output of a command rather than the command itself, you can ignore this message or assign the output to a new variable first:
      ```sh
      readonly command_to_execute="$(print_the_command)"
      "$command_to_execute"
      ```


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1124:
  remediation_points: 50000
  content:
    body: "## ShellCheck directives are only valid in front of complete commands like
      'case' statements, not individual case branches.\n\n### Problematic code:\n\n```sh\ncase
      $? in\n  0) echo \"Success\" ;;\n  # shellcheck disable=2154\n  *) echo \"$cmd
      $flag returned failure\" ;;\nesac\n\n```\n\n### Correct code:\n```sh\n# Applies
      to everything in the `case` statement\n# shellcheck disable=2154\ncase $? in\n
      \ 0) echo \"Success\" ;;\n  *) echo \"$cmd $flag returned failure\" ;;\nesac\n```\n\nor
      \n\n```sh\ncase $? in\n  0) echo \"Success\" ;;\n  *)\n     # Applies to a single
      command within the `case`\n     # shellcheck disable=2154\n     echo \"$cmd
      $flag returned failure\"\n     ;;\nesac\n```\n\n\n### Rationale:\n\nYou appear
      to have put a directive before a branch in a case statement.\n\nShellCheck directives
      can not be scoped to individual branches of `case` statements, only to the entire
      `case`, or to individual commands within it. Please move the directive as appropriate.\n\n(It
      is possible to apply directives to all commands within a `{ ..: }` command group,
      if you truly wish to apply a directive to multiple commands but not the full
      `case` statement.)\n    \n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2189:
  remediation_points: 50000
  content:
    body: |
      ## You can't have | between this redirection and the command it should apply to.

      ### Problematic code:

      ```sh
      < file.txt | grep foo
      ```

      ### Correct code:

      ```sh
      < file.txt grep foo   # or more canonically: grep foo < file.txt
      ```

      ### Rationale:

      ShellCheck has found a stage in a pipeline that consists of a redirection but no command. This doesn't make sense because a redirection without a command will not read or write any data.

      This is most likely to occur when deleting a command that had a redirection, but leaving a `|` behind instead of moving the redirection to a different command:

      ```
      # Match lines with line numbers
      nl < foo.txt | grep bar

      # Incorrect attempt at removing line numbers. grep now has no input:
      < foo.txt | grep bar

      # Line numbers correctly removed. grep now reads foo.txt as intended.
      grep bar < foo.txt
      ```

      ### Exceptions:

      It's technically valid to do e.g. `echo foo | > "$(cat)"` to truncate a file called "foo", but please consider rewriting such code.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1122:
  remediation_points: 50000
  content:
    body: |
      ## Nothing allowed after end token. To continue a command, put it on the line with the `<<`.

      ### Problematic code:

      ```sh
      cat << EOF
      Hello
      EOF | nl
      ```

      ### Correct code:

      ```sh
      cat << EOF | nl
      Hello
      EOF
      ```
      ### Rationale:

      You have a here document, and appear to have added text after the terminating token.

      This is not allowed. If it was meant to continue the command, put it on the line with the `<<`.

      If it helps, look at << "END" as if it was < file, and make sure the resulting command is valid. This is what the shell does. You can then append here document data after the command.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1035:
  remediation_points: 50000
  content:
    body: "## You need a space here\n\n### Problematic code:\n\n```sh\nif ![-z foo
      ]; then true; fi # if command `[-z' w/ args `foo', `]' fails..\n```\n### Correct
      code:\n\n```sh\nif ! [ -z foo ]; then true; fi # if command `[' w/ args `-z',
      `foo', `]' fails..\n```\n\n### Rationale:\n\nBourne shells are very whitespace
      sensitive. Adding or removing spaces can drastically alter the meaning of a
      script. In these cases, ShellCheck has noticed that you're missing a space at
      the position indicated.\n\n### Exceptions\n\nShellCheck does not understand
      [Bash History Expansion](https://www.gnu.org/software/bash/manual/html_node/History-Interaction.html),
      an interactive shell feature also using `!` (such as `!!` to expand to the previous
      command). \n\nThese features are disabled by default in shells and very rarely
      used in scripts, but may occasionally be found in interactively sourced files
      like `.bashrc`. Please ignore the error in these cases.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2214:
  remediation_points: 50000
  content:
    body: |
      ## This case is not specified by getopts.

      ### Problematic code:

      ```sh
      while getopts "vr" n
      do
        case "$n" in
          v) echo "Verbose" ;;
          r) echo "Recursive" ;;
          n) echo "Dry-run" ;;
          *) usage;;
        esac
      done
      ```

      ### Correct code:

      ```sh
      while getopts "vrn" n    # 'n' added here
      do
        case "$n" in
          v) echo "Verbose" ;;
          r) echo "Recursive" ;;
          n) echo "Dry-run" ;;
          *) usage;;
        esac
      done
      ```
      ### Rationale:

      You have a `case` statement in a `while getopts` loop that matches a flag that hasn't been provided in the `getopts` option string.

      Either add the flag to the options list, or delete the case statement.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2004:
  remediation_points: 50000
  content:
    body: |
      # $/${} is unnecessary on arithmetic variables.

      ### Problematic code:

      ```sh
      echo $(($n+1))
      ```

      ### Correct code:

      ```sh
      echo $((n+1))
      ```

      ### Rationale:

      The `$` on regular variables in arithmetic contexts is unnecessary, and can even lead to subtle bugs. This is because the contents of `$((..))` is first expanded into a string, and then evaluated as an expression:

      ```sh
      $ a='1+1'
      $ echo $(($a * 5))    # becomes 1+1*5
      6
      $ echo $((a * 5))     # evaluates as (1+1)*5
      10
      ```

      The `$` is unavoidable for special variables like `$1` vs `1`, `$#` vs `#`. It's also required when adding modifiers to parameters expansions, like `${#var}` or `${var%-}`. ShellCheck does not warn about these cases.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2175:
  remediation_points: 50000
  content:
    body: "## Quote this invalid brace expansion since it should be passed literally
      to eval\n\n### Problematic code:\n\n```sh\neval echo {1..$n}\n```\n\n### Correct
      code:\n\n```sh\neval \"echo {1..$n}\"\n```\n### Rationale:\n\nUsing `eval somecommand
      {1..$n}` depends both on bash silently failing to interpret the brace expansion,
      and on it passing failing brace expansions literally. \n\nRather than depending
      on these questionable features (which already behave differently in other shells),
      use the explicit, predictable way of passing values literally: quoting.\n\n###
      Exceptions:\n\nNone. \n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC1081:
  remediation_points: 50000
  content:
    body: |
      ## Scripts are case sensitive. Use 'if', not 'If'.

      ### Problematic code:

      ```sh
      If true
      Then
        echo "hello"
      Fi
      ```

      ### Correct code:

      ```sh
      if true
      then
        echo "hello"
      fi
      ```

      ### Rationale:

      Shells are case sensitive and do not accept `If` or `IF` in place of lowercase `if`.

      ### Exceptions

      If you're aware of this and insist on naming a function `WHILE`, you can quote the name to prevent shellcheck from thinking you meant `while`. Or if you really want the names, add things like `alias If=if IF=if` to replace those keywords and ask shellcheck to ignore them.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2176:
  remediation_points: 50000
  content:
    body: |
      ## 'time' is undefined for pipelines. time single stage or bash -c instead.

      ### Problematic code:

      ```sh
      time foo | bar```

      ### Correct code:

      To time the most relevant stage:

      ```sh
      foo | { time bar; }
      ```

      To time everything in a pipeline:

      ```sh
      time bash -c 'foo | bar'
      ```

      Note that you can not `time sh -c` to time an entire pipeline, because POSIX does not guarantee that anything other than the last stage is waited on and therefore be recursively counted in the `times()` call that `time` depends on.

      ### Rationale:

      This behavior is explicitly left undefined [in POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/time.html).

      ### Exceptions:

      None. This method is not given in `ksh` or `bash` where `time` is defined for pipelines.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2140:
  remediation_points: 50000
  content:
    body: |
      ##  Word is on the form "A"B"C" (B indicated). Did you mean "ABC" or "A\\"B\\"C"?

      ### Problematic code:

      ```sh
      echo "<img src="foo.png" />" > file.html
      ```

      or

      ```sh
      export "var"="42"
      ```

      ### Correct code:

      ```sh
      echo "<img src=\"foo.png\" />" > file.html
      ```

      or

      ```sh
      export "var=42"
      ```


      ### Rationale:

      This warning triggers when an unquoted literal string is found suspiciously sandwiched between two double quoted strings.

      This usually indicates one of:

      - quotes that were supposed to be nested, and therefore need to be escaped (like the `<img>` example)
      - quotes that are just plain unnecessary (like the `export` example).

      Without escaping, the inner two quotes of the sandwich (the end quote of the first section and the start quote of the second section) are no-ops. The following two statements are identical, so the quotes that were intended to be part of the html output are instead removed:

      ```sh
      echo "<img src="foo.png" />" > file.html
      echo "<img src=foo.png />" > file.html
      ```

      Similarly, these statements are identical, but work as intended:

      ```sh
      export "var"="42"
      export "var=42"
      ```

      ### Exceptions

      If you know that the quotes are ineffectual but you prefer it stylistically, you can ignore this message.

      It's common not to realize that double quotes can span multiple elements, or to stylistically prefer to quote individual variables. For example, these statements are identical, but the first is laboriously and redundantly quoted:

      ```sh
      http://"$user":"$password"@"$host"/"$path"
      "http://$user:$password@$host/$path"
      ```

      When ShellCheck detects the first style (i.e. the double quotes include only a single element each), it will suppress the warning.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2062:
  remediation_points: 50000
  content:
    body: |
      # Quote the grep pattern so the shell won't interpret it.

      ### Problematic code
          grep foo* file

      ### Correct code
          grep "foo*" file

      ### Rationale
      The regex passed to grep frequently contains characters that collide with globs. The code above is supposed to match "f followed by 1 or more o's", but if the directory contains a file called "foo.txt", an unquoted pattern will cause it to become `grep foo.txt file`.

      To prevent this, always quote the regex passed to grep, especially when it contains one or more glob character.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1079:
  remediation_points: 50000
  content:
    body: |
      ## This is actually an end quote, but due to next char it looks suspect.

      See companion warning [[SC1078]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2210:
  remediation_points: 50000
  content:
    body: |
      ## This is a file redirection. Was it supposed to be a comparison or fd operation?

      ### Problematic code:

      ```sh
      if x > 5; then echo "true"; fi
      ```
      or
      ```sh
      foo > /dev/null 2>1
      ```

      ### Correct code:

      ```sh
      if (( x > 5 )); then echo "true"; fi
      ```
      or
      ```sh
      foo > /dev/null 2>&1
      ```
      ### Rationale:

      You are redirecting to or from a filename that is an integer. For example, `ls > file` where `file` happens to be `3`.

      This is not likely to be intentional. The most common causes are:

      1. Trying to compare two numbers, as in `x > 5`. This should instead be `[ "$x" -gt 5 ]` or `(( x > 5 ))`.
      1. Trying similarly to compare command output, as in `grep -c foo file > 100` instead of `[ "$(grep -c foo file)" -gt 100 ]`
      1. Malformed FD operations, such as writing `1>2` instead of `1>&2`.

      ### Exceptions:

      None. If you do want to create a file named `4`, you can quote it to silence shellcheck and make it more clear to humans that it's not supposed to be taken numerically.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1100:
  remediation_points: 50000
  content:
    body: |
      ## This is a unicode dash. Delete and retype as ASCII minus.

      ### Problematic code:

      ```sh
      [[ 3 –gt 2 ]] # Uses unicode en-dash character
      ```

      ### Correct code:

      ```sh
      [[ 3 -gt 2 ]] # Uses regular ASCII hyphen-minus character
      ```
      ### Rationale:

      A character that looks similar to `-` has made its way into your code. This is usually due to copy-pasting from blogs and other websites that formatted code as text, replacing the ASCII hyphen-minus with a Unicode dash character.

      To fix it, simply delete and retype it.

      For a large script, you can use your editor's Search&Replace by copy-pasting the bad dash.

      ### Exceptions:

      None. If you want a literal Unicode dash character, just quote it.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2144:
  remediation_points: 50000
  content:
    body: |
      ##  -e doesn't work with globs. Use a for loop.

      ### Problematic code:

      ```sh
      if [ -e dir/*.mp3 ]
      then
        echo "There are mp3 files."
      fi
      ```

      ### Correct code:

      ```sh
      for file in dir/*.mp3
      do
        if [ -e "$file" ]
        then
          echo "There are mp3 files"
          break
        fi
      done
      ```

      ### Rationale:

      `[ -e file* ]` only works if there's 0 or 1 matches. If there are multiple, it becomes `[ -e file1 file2 ]`, and the test fails.

      `[[ -e file* ]]` doesn't work at all.

      Instead, use a for loop to expand the glob and check each result individually.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1109:
  remediation_points: 50000
  content:
    body: "## This is an unquoted HTML entity. Replace with corresponding character.\n\n###
      Problematic code:\n\n```sh\nfoo &amp;&amp; bar\n```\n\n### Correct code:\n\n```sh\nfoo
      && bar\n```\n\n### Rationale:\n\nThere is an unquoted HTML entity, such as `&amp;`,
      `&gt;` or `&lt;` (instead of `&`, `>` and `<`) in your code. This usually happens
      when copy-pasting from a web site that has mismanaged its code formatting.\n\nYou
      should go through the entire script and replace HTML entities with their corresponding
      characters. \n\nDon't rely on ShellCheck to detect all of them. ShellCheck only
      warns about certain cases in certain contexts, while this issue tends to affect
      the entire script.\n\n### Exceptions:\n\nIf you want to run a command called
      `amp` after backgrounding another command, add a space: `foo & amp;`.\n\n###
      Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2157:
  remediation_points: 50000
  content:
    body: |
      ## Argument to implicit -n is always true due to literal strings.

      ### Problematic code:

      ```sh
      if [ "$foo " ]
      then
        echo "this is always true"
      fi
      ```

      ### Correct code:

      ```sh
      if [ "$foo" ]
      then
        echo "correctly checks value"
      fi
      ```

      ### Rationale:

      Since `[ str ]` checks that the string is non-empty, the space inside the quotes in the problematic code causes the test to always be true, since a string with a space can not be empty.

      Sometimes this is also caused by overquoting an example, e.g. `[ "$foo -gt 0" ]`, which is always true for the same reason. The intention here was `[ "$foo" -gt 0 ]`.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2195:
  remediation_points: 50000
  content:
    body: "## This pattern will never match the case statement's word. Double check
      them.\n\n### Problematic code:\n\n```sh\ncase \"$var \" in      # Trailing space\n
      \ value) echo \"Match\"\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"${var}\"
      in     # No trailing space\n  value) echo \"Match\"\nesac\n```\n### Rationale:\n\nShellCheck
      has detected that one of the patterns in a `case` statement will never match.
      \n\nOften, this is due to mistakes in the case statement word that results in
      unintended literal characters. In the problematic code, there's a trailing space
      that will prevent the match from ever succeeding.\n\nFor more examples of when
      this could happen, see [SC2193](https://github.com/koalaman/shellcheck/wiki/SC2193)
      for the equivalent warning for `[[ .. ]]` statements.\n\nNote that ShellCheck
      warns about individual patterns in a branch, and will flag `*.png` in this example
      even though the branch is not dead:\n\n```\ncase \"${img}.jpg\" in\n  *.png
      | *.jpg) echo \"It's an image\"\nesac\n```\n\n### Exceptions:\n\nNone. If you
      encounter a bug and wish to [[ignore]] this warning, make sure the directive
      goes in front of the `case` and not the individual branch. \n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC1064:
  remediation_points: 50000
  content:
    body: "## Expected a { to open the function definition.\n\n### Problematic code:\n\n```sh\nfoo()
      {\n  echo \"hello world\"\n}\nfoo()\n```\n\n### Correct code:\n\n```sh\nfoo()
      {\n  echo \"hello world\"\n}\nfoo\n```\n### Rationale:\n\nShellCheck found what
      appears to be the start of a function definition, but without a function body.\n\nOne
      common cause is that you are trying to call a function by appending parentheses,
      e.g. `foo()` like in C. Bash does not use or allow parentheses after a function
      name to call it. The function `foo` should be called using just `foo` like in
      the example. \n\nIf you are declaring a function, make sure it looks like the
      correct code above, and that it does not try to declare any parameters (parameters
      are instead accessed with `$1` and up). \n\nIf you are trying to do something
      else, look up the syntax for what you are trying to do.\n\n\n### Exceptions:\n\nPOSIX
      allows the body of a function to be any compound command, e.g. `foo() for i;
      do :; done`. Since this usage is rare, ShellCheck requires the body to be {}
      (or ()). This additional structure requirement helps improve error messages
      and suggestions by not parsing down a path that less advanced users wouldn't
      expect.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2181:
  remediation_points: 50000
  content:
    body: "## Check exit code directly with e.g. 'if mycmd;', not indirectly with
      $?.\n\n### Problematic code:\n\n```sh\nmake mytarget\n\nif [ $? -ne 0 ]\nthen\n
      \ echo \"Build failed\"\nfi\n```\n\n### Correct code:\n\n```sh\nif ! make mytarget\nthen\n
      \ echo \"Build failed\"\nfi\n```\n### Rationale:\n\nRunning a command and then
      checking its exit status `$?` against 0 is redundant.\n\nInstead of just checking
      the exit code of a command, it checks the exit code of a command (e.g. `[`)
      that checks the exit code of a command.\n\nApart from the redundancy, there
      are other reasons to avoid this pattern:\n\n* Since the command and its status
      test are decoupled, inserting an innocent command like `echo \"make finished\"`
      after `make` will cause the `if` statement to silently start comparing `echo`'s
      status instead.\n* Scripts that run or are called with `set -e ` aka `errexit`
      will exit immediately if the command fails, even though they're followed by
      a clause that handles failure. \n* The value of `$?` is overwritten by `[`/`[[`,
      so you can't get the original value in the relevant then/else block (e.g. `if
      mycmd; then echo \"Success\"; else echo \"Failed with $?\"; fi`).\n\nTo check
      that a command returns success, use `if mycommand; then ...`.\n\nTo check that
      a command returns failure, use `if ! mycommand; then ...`.\n\nTo additionally
      capture output with command substitution: `if output=$(mycommand); then ...`\n\nThis
      also applies to `while`/`until` loops.\n\n### Exceptions:\n\nThe default Solaris
      10 bourne shell does not support '!' outside of the test command (`if ! mycommand;
      then ...` returns `!: not found`)\n\n### Notice\n\nOriginal content from the
      ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2194:
  remediation_points: 50000
  content:
    body: |
      ## This word is constant. Did you forget the $ on a variable?

      ### Problematic code:

      ```sh
      case foo in
        bar) echo "Match"
      esac
      ```

      ### Correct code:

      ```sh
      case $foo in
        bar) echo "Match"
      esac
      ```
      ### Rationale:

      You are using a `case` statement to compare a literal word.

      You most likely wanted to treat this word as a `$variable` or `$(command)` instead.

      ### Exceptions:

      None

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1101:
  remediation_points: 50000
  content:
    body: "## Delete trailing spaces after \\ to break line (or use quotes for literal
      space).\n\n### Problematic code:\n\n```sh\n# There are spaces after the backslash:\necho
      hello \\  \n     world\n```\n\n### Correct code:\n\n```sh\n# No spaces after
      the backslash:\necho hello \\\n     world\n```\n### Rationale:\n\nTo break a
      line you can use `\\` before the line break. However, if there are spaces after
      the backslash, the escape will apply to them instead of the line break, and
      the command will not continue on the next line.\n\nDelete the trailing spaces
      to make the line break work correctly.\n\n### Exceptions:\n\nIf you do want
      a literal escaped space at the end of a line you can ignore this error, but
      please reconsider and use quotes instead. Trailing whitespace is invisible and
      frequently stripped on purpose (by editor settings / precommits) or accident
      (copy-paste), and so should not be relied upon for correctness.\n\n### Notice\n\nOriginal
      content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
SC2084:
  remediation_points: 50000
  content:
    body: |
      ## Remove '$' or use '_=$((expr))' to avoid executing output.

      ### Problematic code:

      ```sh
      i=4
      $(( i++ ))
      ```

      ### Correct code:

      Bash, Ksh:

      ```sh
      i=4
      (( i++ ))
      ```

      POSIX (assuming `++` is supported):

      ```sh
      i=4
      _=$(( i++ ))
      ```

      Alternative POSIX version that does not preserve the exit code:

      ```sh
      : $(( i++ ))
      ```

      ### Rationale:

      `$((..))` expands to a number. If it's the only word on the line, the shell will try to execute this number as a command name:

      ```sh
      $ i=4
      $ $(( i++ ))
      4: command not found
      $ echo $i
      5
      ```

      To avoid trying to execute the number as a command name, use one of the methods mentioned:

      ```sh
      $ i=4
      $ _=$(( i++ ))
      $ echo $i
      5
      ```

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2151:
  remediation_points: 50000
  content:
    body: |
      ## Only one integer 0-255 can be returned. Use stdout for other data.

      ### Problematic code:

      ```sh
      myfunc() {
        return foo bar
      }
      ```

      ### Correct code:

      ```sh
      myfunc() {
        echo foo
        echo bar
        return 0
      }
      ```

      ### Rationale:

      In bash, `return` can only be used to signal success or failure (0 = success, 1-255 = failure).

      To return textual or multiple values from a function, write them to stdout and capture them with command substitution instead.

      See [[SC2152]] for more information.

      ### Exceptions:

      None


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2012:
  remediation_points: 50000
  content:
    body: |
      ## Use find instead of ls to better handle non-alphanumeric filenames.

      ### Problematic code:

      ```sh
      ls -l | grep " $USER " | grep '\.txt$'
      ```

      ### Correct code:

      ```sh
      find . -maxdepth 1 -name '*.txt' -user "$USER"
      ```

      ### Rationale:

      `ls` is only intended for human consumption: it has a loose, non-standard format and may "clean up" filenames to make output easier to read.

      Here's an example:

      ```sh
      $ ls -l
      total 0
      -rw-r----- 1 me me 0 Feb  5 20:11 foo?bar
      -rw-r----- 1 me me 0 Feb  5  2011 foo?bar
      -rw-r----- 1 me me 0 Feb  5 20:11 foo?bar
      ```

      It shows three seemingly identical filenames, and did you spot the time format change? How it formats and what it redacts can differ between locale settings, `ls` version, and whether output is a tty.

      `ls` can usually be substituted for `find` if it's the filenames you're after.

      If trying to parse out any other fields, first see whether `stat` (GNU, OS X, FreeBSD) or `find -printf` (GNU) can give you the data you want directly.

      ### Exceptions:

      If the information is intended for the user and not for processing (`ls -l ~/dir | nl; echo "Ok to delete these files?"`) you can ignore this error with a [[directive]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2119:
  remediation_points: 50000
  content:
    body: |
      # Use foo "$@" if function's $1 should mean script's $1.

      See companion warning [[SC2120]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2107:
  remediation_points: 50000
  content:
    body: |
      ## Instead of [ a && b ], use [ a ] && [ b ].

      ### Problematic code:

      ```sh
      [ "$1" = "-v" && -z "$2" ]
      ```

      ### Correct code:

      ```sh
      [ "$1" = "-v" ] && [ -z "$2" ]
      ```

      ### Rationale:

      `&&` can not be used in a `[ .. ]` test expression. Instead, make two `[ .. ]` expressions and put the `&&` between them.

      ### Exceptions:

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2112:
  remediation_points: 50000
  content:
    body: |
      # 'function' keyword is non-standard. Delete it.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2209:
  remediation_points: 50000
  content:
    body: "## Use var=$(command) to assign output (or quote to assign string).\n\n###
      Problematic code:\n\n```sh\nuser=whoami         # Want to run whoami and assign
      output\n\nPAGER=cat git log   # Want to assign the string \"cat\"\n```\n\n###
      Correct code:\n\n```sh\nuser=$(whoami)\n\nPAGER=\"cat\" git log\n```\n\n###
      Rationale:\n\nPutting `var=` in front of a command will not assign its output.
      Use `var=$(my command here)` to execute the command and capture its output.\n\nIf
      you do want to assign a literal string, use quotes to make this clear to shellcheck
      and humans alike. \n\n### Exceptions:\n\nNone. \n\nQuoting a single command
      (as in `PAGER=\"cat\"` above) doesn't change how the script works. It's purely
      to show shellcheck (and humans) that a literal assignment of a command name
      is intentional. \n\nThis warning triggers generally when a variable is assigned
      an unquoted command name (from a list of hard coded names). See related warning
      [[SC2037]] which detects the same kind of error through the patterns `var=value
      -flag` and `var=value *glob*`.\n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC1107:
  remediation_points: 50000
  content:
    body: |
      ## This directive is unknown. It will be ignored.

      ### Problematic code:

      ```sh
      # shellcheck foobar=baz
      echo "Hello World"
      ```

      ### Correct code:

      Depends on your intention.

      ### Rationale:

      ShellCheck doesn't recognize the [[directive]] you're trying to use in a `# shellcheck` comment. See the [[Directive]]s page for supported directives.

      It could be misspelled, or you could be using an older version of shellcheck that doesn't support it yet.

      ### Exceptions:

      None. If you wish to ignore this warning and continue without it, you need version 0.4.5 (commit 88c56ec) or later and a command grouping:

      ```
      # Ignore an unrecognized directive in 0.4.5 or later:
      # shellcheck disable=SC1107
      {
        # shellcheck unrecognized=directive
        echo "Hello World"
      }
      ```

      Before 0.4.5, unrecognized directives are considered parse errors.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2026:
  remediation_points: 50000
  content:
    body: |
      ## This word is outside of quotes. Did you intend to `'nest '"'single quotes'"'` instead'?

      ### Problematic code:

      ```sh
      alias server_uptime='ssh $host 'uptime -p''
      ```

      ### Correct code:

      ```sh
      alias server_uptime='ssh $host '"'uptime -p'"
      ```

      ### Rationale:

      In the first case, the user has four single quotes on a line, wishfully hoping that the shell will match them up as outer quotes around a string with literal single quotes:

      ```sh
      #                   v--------match--------v
      alias server_uptime='ssh $host 'uptime -p''
      #                              ^--match--^
      ```

      The shell, meanwhile, always terminates single quoted strings at the first possible single quote:

      ```sh
      #                   v---match--v
      alias server_uptime='ssh $host 'uptime -p''
      #                                        ^^
      ```

      Which is the same thing as `alias server_uptime='ssh $host uptime' -p`.

      There is no way to nest single quotes. However, single quotes can be placed literally in double quotes, so we can instead concatenate a single quoted string and a double quoted string:

      ```sh
      #                   v--match---v
      alias server_uptime='ssh $host '"'uptime -p'"
      #                               ^---match---^
      ```

      This results in an alias with embedded single quotes.

      ### Exceptions

      None.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC1111:
  remediation_points: 50000
  content:
    body: |
      ## This is a unicode quote. Delete and retype it (or ignore/singlequote for literal).

      ### Problematic code:

      ```sh
      echo "hello world”
      ```

      ### Correct code:

      ```sh
      echo "hello world"
      ```

      ### Rationale:

      Some software, like OS X, Word and WordPress, may automatically replace your regular quotes with slanted Unicode quotes. The shell does not recognize these quotes and will not respect them.

      In this case, you have slanted double quotes in a double quoted string. Try deleting and retyping them, and/or disable “smart quotes” in your editor or OS.

      ### Exceptions

      If you want to use literal slanted double quotes for typographic reasons, you can put them in single quotes to make ShellCheck ignore them:

      ```sh
      printf 'Warning: “wakeonlan” is not installed.\n'
      ```

      You can also just [[ignore]] this warning.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2001:
  remediation_points: 50000
  content:
    body: |
      ## SC2001: See if you can use ${variable//search/replace} instead.

      ### Problematic code:

      ```sh
      string="stirng" ; echo "$string" | sed -e "s/ir/ri/"
      ```

      ### Correct code:

      ```sh
      string="stirng" ; echo "${string//ir/ri}"
      ```

      ### Rationale:

      Let's assume somewhere earlier in your code you have put data into a variable (Ex: $string). Now you want to do a search and replace inside the contents of $string and echo the contents out. You could pass this to sed as done in the example above, but for simple substitutions utilizing the shell for the same feature is a lot simpler and should be utilized whenever possible.

      ### Exceptions

      Occasionally a more complex sed substitution is required. For example, getting the last character of a string.

      ```sh
      string="stirng" ; echo "$string" | sed -e "s/^.*\(.\)$/\1/"
      ```

      This is a bit simple for the example and there are alternative ways of doing this in the shell, but this SC2001 flags on several of my crazy complex sed commands which are beyond the scope of this example. Utilizing some of the more complex capabilities of sed is required occasionally and it is safe to ignore SC2001.


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2167:
  remediation_points: 50000
  content:
    body: |
      ## This parent loop has its index variable overridden.

      See companion warning [[SC2165]].


      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
SC2196:
  remediation_points: 50000
  content:
    body: "##  egrep is non-standard and deprecated. Use grep -E instead.\n\n### Problematic
      code:\n\n```sh\negrep 'foo|bar' file\n```\n\n### Correct code:\n\n```sh\ngrep
      -E 'foo|bar' file\n```\n### Rationale:\n\n`egrep` is a non-standard command.
      Its functionality is provided in POSIX by `grep -E`. [POSIX grep](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/grep.html)
      says:\n\n>This grep has been enhanced in an upwards-compatible way to provide
      the exact functionality of the historical egrep and fgrep commands as well.
      It was the clear intention of the standard developers to consolidate the three
      greps into a single command.\n\nman grep for GNU says:\n\n>Direct invocation
      as either egrep or fgrep is deprecated\n\n### Exceptions:\n\nShellCheck will
      fail to recognize when functions override `egrep`. Consider giving it a different
      name or [[ignore]] this error. \n\n### Notice\n\nOriginal content from the ShellCheck
      https://github.com/koalaman/shellcheck/wiki.\n"
SC1054:
  remediation_points: 50000
  content:
    body: |
      ## You need a space after the '{'.

      ### Problematic code:

      ```sh
      foo() {echo "hello world;}
      ```

      ### Correct code:

      ```sh
      foo() { echo "hello world;}
      ```
      ### Rationale:

      `{` is only recognized as the start of a command group when it's a separate token.

      If it's not a separate token, like in the problematic example, it will be considered a literal character, as if writing `"{echo"` with quotes, and therefore usually cause a syntax error.

      ### Exceptions:

      None.

      ### Notice

      Original content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.
